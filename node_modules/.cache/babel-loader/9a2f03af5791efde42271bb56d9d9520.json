{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport TransportU2F from \"@ledgerhq/hw-transport-u2f\";\nimport TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\nimport Eth from \"@ledgerhq/hw-app-eth\";\nimport _ from \"lodash\";\nimport Ledger from \"../../services/Ledger\";\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst HDKey = require('hdkey');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst hdPathString = `m/44'/60'/0'`;\nconst type = 'Ledger Hardware';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\n\nclass LedgerKeyring extends EventEmitter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.accountIndexes = {};\n    this.type = type;\n    this.page = 0;\n    this.perPage = 5;\n    this.unlockedAccount = 0;\n    this.hdk = new HDKey();\n    this.paths = {};\n    this.deserialize(opts);\n  }\n\n  serialize() {\n    return Promise.resolve({\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      accountIndexes: this.accountIndexes\n    });\n  }\n\n  deserialize() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.hdPath = opts.hdPath || hdPathString;\n    this.accounts = opts.accounts || [];\n    this.accountIndexes = opts.accountIndexes || {};\n\n    if (this._isBIP44()) {\n      // Remove accounts that don't have corresponding account indexes\n      this.accounts = this.accounts.filter(account => Object.keys(this.accountIndexes).includes(ethUtil.toChecksumAddress(account)));\n    }\n\n    return Promise.resolve();\n  }\n\n  isUnlocked() {\n    return !!(this.hdk && this.hdk.publicKey);\n  }\n\n  setAccountToUnlock(index) {\n    this.unlockedAccount = parseInt(index, 10);\n  }\n\n  setHdPath(hdPath) {\n    // Reset HDKey if the path changes\n    if (this.hdPath !== hdPath) {\n      this.hdk = new HDKey();\n    }\n\n    this.hdPath = hdPath;\n  }\n\n  unlock(hdPath) {\n    if (this.isUnlocked() && !hdPath) return Promise.resolve('already unlocked');\n    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath;\n    return new Promise(async (resolve, reject) => {\n      try {\n        const app = await this._getETH();\n        const payload = await app.getAddress(path, false, true);\n        this.hdk.publicKey = new Buffer(payload.publicKey, 'hex');\n        this.hdk.chainCode = new Buffer(payload.chainCode, 'hex');\n        resolve(payload.address.toLowerCase());\n      } catch (e) {\n        reject(new Error(e.message || 'Unknown error'));\n      }\n    });\n  }\n\n  addAccounts() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return new Promise((resolve, reject) => {\n      this.unlock().then(async _ => {\n        const from = this.unlockedAccount;\n        const to = from + n;\n        this.accounts = [];\n\n        for (let i = from; i < to; i++) {\n          let address;\n\n          if (this._isBIP44()) {\n            const path = this._getPathForIndex(i);\n\n            address = await this.unlock(path);\n            this.accountIndexes[ethUtil.toChecksumAddress(address)] = i;\n          } else {\n            address = this._addressFromIndex(pathBase, i);\n          }\n\n          this.accounts.push(address);\n          this.page = 0;\n        }\n\n        resolve(this.accounts);\n      }).catch(e => {\n        reject(e);\n      });\n    });\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this._getPage(1);\n  }\n\n  getNextPage() {\n    return this._getPage(1);\n  }\n\n  getPreviousPage() {\n    return this._getPage(-1);\n  }\n\n  getAccounts() {\n    return Promise.resolve(this.accounts.slice());\n  }\n\n  removeAccount(address) {\n    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n\n    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());\n    delete this.accountIndexes[ethUtil.toChecksumAddress(address)];\n  }\n\n  async signAndSendTransaction(fromAddress, transaction, provider) {\n    const unlockResult = await this.unlock();\n    let hdPath;\n\n    if (this._isBIP44()) {\n      const checksummedAddress = ethUtil.toChecksumAddress(fromAddress);\n\n      if (!Object.keys(this.accountIndexes).includes(checksummedAddress)) {\n        throw new Error(`Ledger: Index for address '${checksummedAddress}' not found`);\n      }\n\n      hdPath = this._getPathForIndex(this.accountIndexes[checksummedAddress]);\n    } else {\n      hdPath = this._toLedgerPath(this._pathFromAddress(fromAddress));\n    }\n\n    if (_.isNil(transaction.getSequenceOverride())) {\n      let sequence = await provider.getTransactionCount(fromAddress);\n      sequence = sequence + 1;\n      transaction.setSequence(sequence);\n    }\n\n    transaction.setFrom(ethUtil.toChecksumAddress(fromAddress));\n    const app = await this._getETH();\n    const signedTxRaw = await Ledger.signTransaction(app, hdPath, transaction);\n    const result = provider.sendTransaction(signedTxRaw);\n    return Promise.resolve(result);\n  }\n\n  signMessage(withAccount, data) {\n    throw new Error('Not supported on this device');\n  } // For personal_sign, we need to prefix the message:\n\n\n  signPersonalMessage(withAccount, message) {\n    throw new Error('Not supported on this device');\n  }\n\n  signTypedData(withAccount, typedData) {\n    throw new Error('Not supported on this device');\n  }\n\n  exportAccount(address) {\n    throw new Error('Not supported on this device');\n  }\n\n  forgetDevice() {\n    this.accounts = [];\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.paths = {};\n    this.hdk = new HDKey();\n  }\n  /* PRIVATE METHODS */\n\n\n  async _getPage(increment) {\n    this.page += increment;\n\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n\n    const from = (this.page - 1) * this.perPage;\n    const to = from + this.perPage;\n    await this.unlock();\n    let accounts;\n\n    if (this._isBIP44()) {\n      accounts = await this._getAccountsBIP44(from, to);\n    } else {\n      accounts = this._getAccountsLegacy(from, to);\n    }\n\n    return accounts;\n  }\n\n  async _getAccountsBIP44(from, to) {\n    const accounts = [];\n\n    for (let i = from; i < to; i++) {\n      const path = this._getPathForIndex(i);\n\n      const address = await this.unlock(path);\n      accounts.push({\n        address: address.toLowerCase(),\n        balance: null,\n        index: i\n      });\n    }\n\n    return accounts;\n  }\n\n  _getAccountsLegacy(from, to) {\n    const accounts = [];\n\n    for (let i = from; i < to; i++) {\n      const address = this._addressFromIndex(pathBase, i);\n\n      accounts.push({\n        address: address,\n        balance: null,\n        index: i\n      });\n      this.paths[ethUtil.toChecksumAddress(address)] = i;\n    }\n\n    return accounts;\n  }\n\n  _padLeftEven(hex) {\n    return hex.length % 2 !== 0 ? `0${hex}` : hex;\n  }\n\n  _normalize(buf) {\n    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase());\n  }\n\n  _addressFromIndex(pathBase, i) {\n    const dkey = this.hdk.derive(`${pathBase}/${i}`);\n    const address = ethUtil.publicToAddress(dkey.publicKey, true).toString('hex');\n    return ethUtil.toChecksumAddress(address).toLowerCase();\n  }\n\n  _pathFromAddress(address) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address);\n    let index = this.paths[checksummedAddress];\n\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address');\n    }\n\n    return this._getPathForIndex(index);\n  }\n\n  _getPathForIndex(index) {\n    // Check if the path is BIP 44 (Ledger Live)\n    return this._isBIP44() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}${index}`;\n  }\n\n  _isBIP44() {\n    return this.hdPath === `m/44'/60'/0'/0/0`;\n  }\n\n  _toLedgerPath(path) {\n    return path.toString().replace('m/', '');\n  }\n\n  async _getETH() {\n    let transport;\n\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n      transport = await TransportU2F.create();\n    } else {\n      transport = await TransportWebUSB.create();\n    }\n\n    const app = new Eth(transport);\n    return app;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nLedgerKeyring.type = type;\nconst _default = LedgerKeyring;\nexport default _default;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(hdPathString, \"hdPathString\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/ledger/index.js\");\n  reactHotLoader.register(type, \"type\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/ledger/index.js\");\n  reactHotLoader.register(pathBase, \"pathBase\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/ledger/index.js\");\n  reactHotLoader.register(MAX_INDEX, \"MAX_INDEX\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/ledger/index.js\");\n  reactHotLoader.register(LedgerKeyring, \"LedgerKeyring\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/ledger/index.js\");\n  reactHotLoader.register(_default, \"default\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/ledger/index.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["TransportU2F","TransportWebUSB","Eth","_","Ledger","EventEmitter","require","HDKey","ethUtil","hdPathString","type","pathBase","MAX_INDEX","LedgerKeyring","constructor","opts","accountIndexes","page","perPage","unlockedAccount","hdk","paths","deserialize","serialize","Promise","resolve","hdPath","accounts","_isBIP44","filter","account","Object","keys","includes","toChecksumAddress","isUnlocked","publicKey","setAccountToUnlock","index","parseInt","setHdPath","unlock","path","_toLedgerPath","reject","app","_getETH","payload","getAddress","Buffer","chainCode","address","toLowerCase","e","Error","message","addAccounts","n","then","from","to","i","_getPathForIndex","_addressFromIndex","push","catch","getFirstPage","_getPage","getNextPage","getPreviousPage","getAccounts","slice","removeAccount","map","a","signAndSendTransaction","fromAddress","transaction","provider","unlockResult","checksummedAddress","_pathFromAddress","isNil","getSequenceOverride","sequence","getTransactionCount","setSequence","setFrom","signedTxRaw","signTransaction","result","sendTransaction","signMessage","withAccount","data","signPersonalMessage","signTypedData","typedData","exportAccount","forgetDevice","increment","_getAccountsBIP44","_getAccountsLegacy","balance","_padLeftEven","hex","length","_normalize","buf","bufferToHex","dkey","derive","publicToAddress","toString","replace","transport","navigator","userAgent","indexOf","create"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/ledger/index.js"],"sourcesContent":["import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\nimport TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\nimport Eth from \"@ledgerhq/hw-app-eth\";\nimport _ from \"lodash\";\nimport Ledger from \"../../services/Ledger\";\n\nconst {EventEmitter} = require('events')\nconst HDKey = require('hdkey')\nconst ethUtil = require('ethereumjs-util')\n\nconst hdPathString = `m/44'/60'/0'`\nconst type = 'Ledger Hardware'\nconst pathBase = 'm'\nconst MAX_INDEX = 1000\n\nclass LedgerKeyring extends EventEmitter {\n    constructor (opts = {}) {\n        super()\n        this.accountIndexes = {}\n        this.type = type\n        this.page = 0\n        this.perPage = 5\n        this.unlockedAccount = 0\n        this.hdk = new HDKey()\n        this.paths = {}\n        this.deserialize(opts)\n    }\n\n    serialize () {\n        return Promise.resolve({\n            hdPath: this.hdPath,\n            accounts: this.accounts,\n            accountIndexes: this.accountIndexes,\n        })\n    }\n\n    deserialize (opts = {}) {\n        this.hdPath = opts.hdPath || hdPathString\n        this.accounts = opts.accounts || []\n        this.accountIndexes = opts.accountIndexes || {}\n\n        if (this._isBIP44()) {\n            // Remove accounts that don't have corresponding account indexes\n            this.accounts = this.accounts\n                .filter(account => Object.keys(this.accountIndexes).includes(ethUtil.toChecksumAddress(account)))\n        }\n\n        return Promise.resolve()\n    }\n\n    isUnlocked () {\n        return !!(this.hdk && this.hdk.publicKey)\n    }\n\n    setAccountToUnlock (index) {\n        this.unlockedAccount = parseInt(index, 10)\n    }\n\n    setHdPath (hdPath) {\n        // Reset HDKey if the path changes\n        if (this.hdPath !== hdPath) {\n            this.hdk = new HDKey()\n        }\n        this.hdPath = hdPath\n    }\n\n    unlock (hdPath) {\n        if (this.isUnlocked() && !hdPath) return Promise.resolve('already unlocked')\n        const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath\n        return new Promise(async (resolve, reject) => {\n            try {\n                const app = await this._getETH();\n                const payload = await app.getAddress(path, false, true);\n                this.hdk.publicKey = new Buffer(payload.publicKey, 'hex');\n                this.hdk.chainCode = new Buffer(payload.chainCode, 'hex');\n\n                resolve(payload.address.toLowerCase());\n            }\n            catch (e) {\n                reject(new Error(e.message || 'Unknown error'))\n            }\n        })\n    }\n\n    addAccounts (n = 1) {\n        return new Promise((resolve, reject) => {\n            this.unlock()\n                .then(async _ => {\n                    const from = this.unlockedAccount\n                    const to = from + n\n                    this.accounts = []\n                    for (let i = from; i < to; i++) {\n                        let address\n                        if (this._isBIP44()) {\n                            const path = this._getPathForIndex(i)\n                            address = await this.unlock(path)\n                            this.accountIndexes[ethUtil.toChecksumAddress(address)] = i\n                        } else {\n                            address = this._addressFromIndex(pathBase, i)\n                        }\n                        this.accounts.push(address)\n                        this.page = 0\n                    }\n                    resolve(this.accounts)\n                })\n                .catch(e => {\n                    reject(e)\n                })\n        })\n    }\n\n    getFirstPage () {\n        this.page = 0\n        return this._getPage(1)\n    }\n\n    getNextPage () {\n        return this._getPage(1)\n    }\n\n    getPreviousPage () {\n        return this._getPage(-1)\n    }\n\n    getAccounts () {\n        return Promise.resolve(this.accounts.slice())\n    }\n\n    removeAccount (address) {\n        if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {\n            throw new Error(`Address ${address} not found in this keyring`)\n        }\n        this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase())\n        delete this.accountIndexes[ethUtil.toChecksumAddress(address)]\n    }\n\n    async signAndSendTransaction (fromAddress, transaction, provider) {\n        const unlockResult = await this.unlock();\n        let hdPath;\n        if (this._isBIP44()) {\n            const checksummedAddress = ethUtil.toChecksumAddress(fromAddress)\n            if (!Object.keys(this.accountIndexes).includes(checksummedAddress)) {\n                throw (new Error(`Ledger: Index for address '${checksummedAddress}' not found`))\n            }\n            hdPath = this._getPathForIndex(this.accountIndexes[checksummedAddress])\n        } else {\n            hdPath = this._toLedgerPath(this._pathFromAddress(fromAddress))\n        }\n\n        if(_.isNil(transaction.getSequenceOverride())){\n            let sequence = await provider.getTransactionCount(fromAddress);\n            sequence = sequence + 1;\n            transaction.setSequence(sequence);\n        }\n        transaction.setFrom(ethUtil.toChecksumAddress(fromAddress));\n\n        const app = await this._getETH();\n        const signedTxRaw = await Ledger.signTransaction(app, hdPath, transaction);\n        const result = provider.sendTransaction(signedTxRaw);\n\n        return Promise.resolve(result);\n    }\n\n    signMessage (withAccount, data) {\n        throw new Error('Not supported on this device')\n    }\n\n    // For personal_sign, we need to prefix the message:\n    signPersonalMessage (withAccount, message) {\n        throw new Error('Not supported on this device')\n    }\n\n    signTypedData (withAccount, typedData) {\n        throw new Error('Not supported on this device')\n    }\n\n    exportAccount (address) {\n        throw new Error('Not supported on this device')\n    }\n\n    forgetDevice () {\n        this.accounts = []\n        this.page = 0\n        this.unlockedAccount = 0\n        this.paths = {}\n        this.hdk = new HDKey()\n    }\n\n    /* PRIVATE METHODS */\n\n    async _getPage (increment) {\n        this.page += increment\n\n        if (this.page <= 0) { this.page = 1 }\n        const from = (this.page - 1) * this.perPage\n        const to = from + this.perPage\n\n        await this.unlock()\n        let accounts\n        if (this._isBIP44()) {\n            accounts = await this._getAccountsBIP44(from, to)\n        } else {\n            accounts = this._getAccountsLegacy(from, to)\n        }\n        return accounts\n    }\n\n    async _getAccountsBIP44 (from, to) {\n        const accounts = []\n\n        for (let i = from; i < to; i++) {\n            const path = this._getPathForIndex(i)\n            const address = await this.unlock(path)\n            accounts.push({\n                address: address.toLowerCase(),\n                balance: null,\n                index: i,\n            })\n        }\n        return accounts\n    }\n\n    _getAccountsLegacy (from, to) {\n        const accounts = []\n\n        for (let i = from; i < to; i++) {\n            const address = this._addressFromIndex(pathBase, i)\n            accounts.push({\n                address: address,\n                balance: null,\n                index: i,\n            })\n            this.paths[ethUtil.toChecksumAddress(address)] = i\n        }\n        return accounts\n    }\n\n    _padLeftEven (hex) {\n        return hex.length % 2 !== 0 ? `0${hex}` : hex\n    }\n\n    _normalize (buf) {\n        return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())\n    }\n\n    _addressFromIndex (pathBase, i) {\n        const dkey = this.hdk.derive(`${pathBase}/${i}`)\n        const address = ethUtil\n            .publicToAddress(dkey.publicKey, true)\n            .toString('hex')\n        return ethUtil.toChecksumAddress(address).toLowerCase()\n    }\n\n    _pathFromAddress (address) {\n        const checksummedAddress = ethUtil.toChecksumAddress(address)\n        let index = this.paths[checksummedAddress]\n        if (typeof index === 'undefined') {\n            for (let i = 0; i < MAX_INDEX; i++) {\n                if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n                    index = i\n                    break\n                }\n            }\n        }\n\n        if (typeof index === 'undefined') {\n            throw new Error('Unknown address')\n        }\n        return this._getPathForIndex(index)\n    }\n\n    _getPathForIndex (index) {\n        // Check if the path is BIP 44 (Ledger Live)\n        return this._isBIP44() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}${index}`\n    }\n\n    _isBIP44 () {\n        return this.hdPath === `m/44'/60'/0'/0/0`\n    }\n\n    _toLedgerPath (path) {\n        return path.toString().replace('m/', '')\n    }\n\n    async _getETH () {\n        let transport;\n        if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1){\n            transport = await TransportU2F.create();\n        }\n        else {\n            transport = await TransportWebUSB.create();\n        }\n        const app = new Eth(transport);\n\n        return app;\n    }\n}\n\nLedgerKeyring.type = type;\n\nexport default LedgerKeyring;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}