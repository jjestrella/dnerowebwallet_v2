{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport ObservableStore from './ObservableStore';\n/**\n * An ObservableStore that can composes a flat\n * structure of child stores based on configuration\n */\n\nexport default class ComposableObservableStore extends ObservableStore {\n  /**\n   * Create a new store\n   *\n   * @param {Object} [initState] - The initial store state\n   * @param {Object} [config] - Map of internal state keys to child stores\n   */\n  constructor(initState, config) {\n    super(initState);\n    this.updateStructure(config);\n  }\n  /**\n   * Composes a new internal store subscription structure\n   *\n   * @param {Object} [config] - Map of internal state keys to child stores\n   */\n\n\n  updateStructure(config) {\n    this.config = config;\n    this.removeAllListeners();\n\n    for (const key in config) {\n      if (Object.prototype.hasOwnProperty.call(config, key)) {\n        config[key].subscribe(state => {\n          this.updateState({\n            [key]: state\n          });\n        });\n      }\n    }\n  }\n  /**\n   * Merges all child store state into a single object rather than\n   * returning an object keyed by child store class name\n   *\n   * @returns {Object} Object containing merged child store state\n   */\n\n\n  getFlatState() {\n    let flatState = {};\n\n    for (const key in this.config) {\n      if (Object.prototype.hasOwnProperty.call(this.config, key)) {\n        const controller = this.config[key];\n        const state = controller.getState ? controller.getState() : controller.state;\n        flatState = { ...flatState,\n          ...state\n        };\n      }\n    }\n\n    return flatState;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(ComposableObservableStore, \"ComposableObservableStore\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/utils/ComposableObservableStore.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["ObservableStore","ComposableObservableStore","constructor","initState","config","updateStructure","removeAllListeners","key","Object","prototype","hasOwnProperty","call","subscribe","state","updateState","getFlatState","flatState","controller","getState"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/utils/ComposableObservableStore.js"],"sourcesContent":["import ObservableStore from './ObservableStore'\n\n/**\n * An ObservableStore that can composes a flat\n * structure of child stores based on configuration\n */\nexport default class ComposableObservableStore extends ObservableStore {\n    /**\n     * Create a new store\n     *\n     * @param {Object} [initState] - The initial store state\n     * @param {Object} [config] - Map of internal state keys to child stores\n     */\n    constructor(initState, config) {\n        super(initState);\n        this.updateStructure(config);\n    }\n\n    /**\n     * Composes a new internal store subscription structure\n     *\n     * @param {Object} [config] - Map of internal state keys to child stores\n     */\n    updateStructure(config) {\n        this.config = config;\n        this.removeAllListeners();\n        for (const key in config) {\n            if (Object.prototype.hasOwnProperty.call(config, key)) {\n                config[key].subscribe((state) => {\n                    this.updateState({ [key]: state });\n                });\n            }\n        }\n    }\n\n    /**\n     * Merges all child store state into a single object rather than\n     * returning an object keyed by child store class name\n     *\n     * @returns {Object} Object containing merged child store state\n     */\n    getFlatState() {\n        let flatState = {};\n        for (const key in this.config) {\n            if (Object.prototype.hasOwnProperty.call(this.config, key)) {\n                const controller = this.config[key];\n                const state = controller.getState\n                    ? controller.getState()\n                    : controller.state;\n                flatState = { ...flatState, ...state };\n            }\n        }\n        return flatState;\n    }\n}\n"],"mappings":";;;;;;;;;AAAA,OAAOA,eAAP,MAA4B,mBAA5B;AAEA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,yBAAN,SAAwCD,eAAxC,CAAwD;EACnE;AACJ;AACA;AACA;AACA;AACA;EACIE,WAAW,CAACC,SAAD,EAAYC,MAAZ,EAAoB;IAC3B,MAAMD,SAAN;IACA,KAAKE,eAAL,CAAqBD,MAArB;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIC,eAAe,CAACD,MAAD,EAAS;IACpB,KAAKA,MAAL,GAAcA,MAAd;IACA,KAAKE,kBAAL;;IACA,KAAK,MAAMC,GAAX,IAAkBH,MAAlB,EAA0B;MACtB,IAAII,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCP,MAArC,EAA6CG,GAA7C,CAAJ,EAAuD;QACnDH,MAAM,CAACG,GAAD,CAAN,CAAYK,SAAZ,CAAuBC,KAAD,IAAW;UAC7B,KAAKC,WAAL,CAAiB;YAAE,CAACP,GAAD,GAAOM;UAAT,CAAjB;QACH,CAFD;MAGH;IACJ;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIE,YAAY,GAAG;IACX,IAAIC,SAAS,GAAG,EAAhB;;IACA,KAAK,MAAMT,GAAX,IAAkB,KAAKH,MAAvB,EAA+B;MAC3B,IAAII,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC,KAAKP,MAA1C,EAAkDG,GAAlD,CAAJ,EAA4D;QACxD,MAAMU,UAAU,GAAG,KAAKb,MAAL,CAAYG,GAAZ,CAAnB;QACA,MAAMM,KAAK,GAAGI,UAAU,CAACC,QAAX,GACRD,UAAU,CAACC,QAAX,EADQ,GAERD,UAAU,CAACJ,KAFjB;QAGAG,SAAS,GAAG,EAAE,GAAGA,SAAL;UAAgB,GAAGH;QAAnB,CAAZ;MACH;IACJ;;IACD,OAAOG,SAAP;EACH;;EA/CkE;EAAA;IAAA;IAAA;EAAA;;AAAA;;;;;;;;;;0BAAlDf,yB"},"metadata":{},"sourceType":"module"}