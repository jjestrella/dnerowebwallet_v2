{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport _ from 'lodash';\nimport * as dnerojs from '@dnerolabs/dnero-js';\nimport KeyringController from '../controllers/keyring';\nimport ComposableObservableStore from '../utils/ComposableObservableStore';\nimport PreferencesController from './preferences';\nimport AccountManager from './account-manager';\nimport TransactionsController from './transactions';\nimport SimpleKeyring from '../keyrings/simple';\nimport TrezorKeyring from '../keyrings/trezor';\nimport LedgerKeyring from \"../keyrings/ledger\";\nimport { EthereumDerivationPath, EthereumLedgerLiveDerivationPath, EthereumOtherDerivationPath, NumPathsPerPage, DneroDevDerivationPath } from \"../services/Wallet\";\nimport { updateAccountBalances } from \"../state/actions/Wallet\";\n\nconst {\n  EventEmitter\n} = require('events');\n\nexport default class DneroWalletController extends EventEmitter {\n  constructor(opts) {\n    super();\n\n    this.getProvider = () => {\n      return this.provider;\n    };\n\n    this.setProvider = provider => {\n      this.provider = provider;\n    };\n\n    this.sendUpdate = this._sendUpdate.bind(this);\n    this.opts = opts;\n    const initState = opts.initState || {};\n    this.store = new ComposableObservableStore(initState);\n    this.memStore = new ComposableObservableStore();\n    this.preferencesController = new PreferencesController({\n      initState: initState.preferencesController\n    });\n    this.preferencesController.on('networkChanged', newNetwork => {\n      const selectedAddress = this.preferencesController.getSelectedAddress();\n      const newProvider = new dnerojs.providers.HttpProvider(newNetwork.chainId);\n      this.setProvider(newProvider);\n\n      if (selectedAddress) {\n        this.accountManager.updateAccounts();\n        this.accountManager.updateAccountStakes(selectedAddress);\n        this.accountManager.detectNewTokens();\n        this.transactionsController.updateAccountTransactions(selectedAddress);\n      }\n    });\n    this.preferencesController.on('accountTokensUpdated', () => {\n      this.accountManager.updateAccounts();\n    });\n    const network = this.preferencesController.getNetwork();\n    this.provider = new dnerojs.providers.HttpProvider(network.chainId);\n    const additionalKeyrings = [TrezorKeyring, LedgerKeyring];\n    this.keyringController = new KeyringController({\n      initState: initState.keyringController,\n      keyringTypes: additionalKeyrings\n    });\n    this.keyringController.memStore.subscribe(s => this._onKeyringVaultUpdate(s));\n    this.accountManager = new AccountManager({\n      getProvider: this.getProvider,\n      getNetwork: this.preferencesController.getNetwork.bind(this.preferencesController),\n      getTokens: this.preferencesController.getTokens.bind(this.preferencesController),\n      preferencesController: this.preferencesController\n    });\n    this.transactionsController = new TransactionsController({\n      initState: initState.transactionsController,\n      getProvider: this.getProvider,\n      preferencesController: this.preferencesController,\n      signAndSendTransaction: this.keyringController.signAndSendTransaction.bind(this.keyringController),\n      updateAccounts: this.accountManager.updateAccounts.bind(this.accountManager)\n    });\n    this.store.updateStructure({\n      keyringController: this.keyringController.store,\n      preferencesController: this.preferencesController.store\n    });\n    this.preferencesController.store.subscribe(data => {\n      try {\n        if (localStorage) {\n          localStorage.setItem('preferencesController', JSON.stringify(_.pick(data, 'accountTokens')));\n        }\n      } catch (e) {}\n    });\n    this.memStore.updateStructure({\n      keyringController: this.keyringController.memStore,\n      preferencesController: this.preferencesController.store,\n      transactionsController: this.transactionsController.memStore,\n      accountManager: this.accountManager.store\n    });\n    this.memStore.subscribe(data => {\n      this.sendUpdate();\n    });\n\n    const sendUpdate = data => {// TODO anything?\n    };\n\n    this.on('update', sendUpdate);\n    this.RPCApi = this._setupRPCApi();\n  }\n\n  /**\n   * The dnero-wallet-state of the various controllers, made available to the UI\n   *\n   * @returns {Object} status\n   */\n  getState() {\n    const {\n      vault\n    } = this.keyringController.store.getState();\n    const isInitialized = Boolean(vault);\n    return { ...{\n        isInitialized\n      },\n      ...this.memStore.getFlatState()\n    };\n  }\n  /**\n   * A method for emitting the full Dnero Wallet state to all registered listeners.\n   * @private\n   */\n\n\n  _sendUpdate() {\n    this.emit('update', this.getState());\n  }\n  /**\n   * Handle a KeyringController update\n   * @param {Object} state - the KC state\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  async _onKeyringVaultUpdate(state) {\n    const {\n      keyrings\n    } = state;\n    const addresses = keyrings.reduce((acc, _ref) => {\n      let {\n        accounts\n      } = _ref;\n      return acc.concat(accounts);\n    }, []);\n\n    if (!addresses.length) {\n      return;\n    } // Ensure preferences + identities controller know about all addresses\n\n\n    this.preferencesController.syncAddresses(addresses);\n    this.accountManager.syncAddresses(addresses);\n  }\n  /**\n   * Sets the first address in the state to the selected address\n   */\n\n\n  async selectFirstIdentity() {\n    const {\n      identities\n    } = this.preferencesController.store.getState();\n    const address = Object.keys(identities)[0];\n    await this.preferencesController.setSelectedAddress(address);\n  }\n\n  _setupRPCApi() {\n    return {\n      getState: this._getState.bind(this),\n      // Transactions\n      addTransactionRequest: this._addTransactionRequest.bind(this),\n      approveTransactionRequest: this._approveTransactionRequest.bind(this),\n      rejectTransactionRequest: this._rejectTransactionRequest.bind(this),\n      // Tokens\n      addToken: this._addToken.bind(this),\n      removeToken: this._removeToken.bind(this),\n      // Preferences\n      setSelectedAddress: this._setSelectedAddress.bind(this),\n      setSelectedNetwork: this._setSelectedNetwork.bind(this),\n      // Accounts\n      importAccount: this._importAccount.bind(this),\n      sendTransaction: this._sendTransaction.bind(this),\n      updateAccountStakes: this._updateAccountStakes.bind(this),\n      updateAccountBalances: this._updateAccountBalances.bind(this),\n      updateAccountTransactions: this._updateAccountTransactions.bind(this),\n      // Hardware wallets\n      connectHardware: this.connectHardware.bind(this),\n      forgetDevice: this.forgetDevice.bind(this),\n      checkHardwareStatus: this.checkHardwareStatus.bind(this),\n      unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this)\n    };\n  }\n\n  async _sendTransaction(args) {\n    const {\n      transactionRequest\n    } = args;\n\n    if (!this.getState().isInitialized) {\n      throw Error('Your Dnero Wallet has not be initialized.');\n    }\n\n    const result = await this.transactionsController.addTransactionRequest(transactionRequest);\n    return result;\n  }\n\n  async _getState(args) {\n    const result = await this.getState();\n    return result;\n  }\n\n  async _addTransactionRequest(args) {\n    const {\n      transactionRequest\n    } = args;\n    const result = await this.transactionsController.addTransactionRequest(transactionRequest);\n    return result;\n  }\n\n  async _approveTransactionRequest(args) {\n    const {\n      transactionRequestId,\n      onDependencySent\n    } = args;\n    const result = await this.transactionsController.approveTransactionRequest(transactionRequestId, onDependencySent);\n    return result;\n  }\n\n  async _rejectTransactionRequest(args) {\n    const {\n      transactionRequestId\n    } = args;\n    const result = await this.transactionsController.rejectTransactionRequest(transactionRequestId);\n    return result;\n  }\n\n  async _addToken(args) {\n    const {\n      token\n    } = args;\n    const {\n      address,\n      symbol,\n      decimals,\n      image\n    } = token;\n    const result = await this.preferencesController.addToken(address, symbol, decimals, image);\n    return result;\n  }\n\n  async _removeToken(args) {\n    const {\n      address\n    } = args;\n    const result = await this.preferencesController.removeToken(address);\n    return result;\n  }\n\n  async _setSelectedAddress(args) {\n    const {\n      address\n    } = args;\n    const result = await this.preferencesController.setSelectedAddress(address);\n    return result;\n  }\n\n  async _setSelectedNetwork(args) {\n    const {\n      network\n    } = args;\n    const result = await this.preferencesController.setNetwork(network);\n    return result;\n  }\n\n  async _importAccount(args) {\n    const {\n      importType,\n      privateKey,\n      encryptedJson,\n      encryptedJsonPassword,\n      name\n    } = args;\n    let privateKeyToImport = null;\n\n    if (privateKey) {\n      privateKeyToImport = privateKey;\n    } else if (encryptedJson && encryptedJsonPassword) {\n      const wallet = dnerojs.Wallet.fromEncryptedJson(encryptedJson, encryptedJsonPassword, null);\n      privateKeyToImport = wallet.privateKey;\n    } else {\n      throw new Error('Invalid account.');\n    }\n\n    const keyring = await this.keyringController.addNewKeyring(SimpleKeyring.type, [privateKeyToImport]);\n    const accounts = await keyring.getAccounts(); // update accounts in preferences controller\n\n    const allAccounts = await this.keyringController.getAccounts();\n    this.preferencesController.setAddresses(allAccounts); // Set account name\n\n    const newAccount = accounts[0];\n\n    if (newAccount && name) {\n      await this.preferencesController.setAccountName(newAccount, name);\n    } // set new account as selected\n\n\n    await this.preferencesController.setSelectedAddress(newAccount);\n    this.accountManager.start();\n    return true;\n  }\n\n  async _updateAccountStakes(args) {\n    const {\n      address\n    } = args;\n    return this.accountManager.updateAccountStakes(address);\n  }\n\n  async _updateAccountBalances(args) {\n    const {} = args;\n    return this.accountManager.updateAccounts();\n  }\n\n  async _updateAccountTransactions(args) {\n    const {\n      address\n    } = args;\n    return this.transactionsController.updateAccountTransactions(address);\n  } //\n  // Hardware\n  //\n\n\n  async getKeyringForDevice(deviceName) {\n    let hdPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let keyringName = null;\n\n    switch (deviceName) {\n      case 'trezor':\n        keyringName = TrezorKeyring.type;\n        break;\n\n      case 'ledger':\n        keyringName = LedgerKeyring.type;\n        break;\n\n      default:\n        throw new Error('DneroWalletController:getKeyringForDevice - Unknown device');\n    }\n\n    let keyring = await this.keyringController.getKeyringsByType(keyringName)[0];\n\n    if (!keyring) {\n      keyring = await this.keyringController.addNewKeyring(keyringName);\n    }\n\n    if (hdPath && keyring.setHdPath) {\n      // Transform the hdPath so it can be used properly\n      if (hdPath === EthereumDerivationPath) {\n        hdPath = EthereumDerivationPath;\n      } else if (hdPath === EthereumOtherDerivationPath) {\n        hdPath = EthereumOtherDerivationPath;\n      } else if (hdPath === EthereumLedgerLiveDerivationPath) {\n        hdPath = \"m/44'/60'/0'/0/0\";\n      }\n\n      keyring.setHdPath(hdPath);\n    }\n\n    return keyring;\n  }\n  /**\n   * Fetch account list from a trezor device.\n   *\n   * @returns [] accounts\n   */\n\n\n  async connectHardware(deviceName, page, hdPath) {\n    const keyring = await this.getKeyringForDevice(deviceName, hdPath);\n    let accounts = [];\n\n    switch (page) {\n      case -1:\n        accounts = await keyring.getPreviousPage();\n        break;\n\n      case 1:\n        accounts = await keyring.getNextPage();\n        break;\n\n      default:\n        accounts = await keyring.getFirstPage();\n    } // Merge with existing accounts\n    // and make sure addresses are not repeated\n\n\n    const oldAccounts = await this.keyringController.getAccounts();\n    const accountsToTrack = [...new Set(oldAccounts.concat(accounts.map(a => a.address.toLowerCase())))];\n    this.accountManager.syncAddresses(accountsToTrack);\n    return accounts;\n  }\n  /**\n   * Check if the device is unlocked\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  async checkHardwareStatus(deviceName, hdPath) {\n    const keyring = await this.getKeyringForDevice(deviceName, hdPath);\n    return keyring.isUnlocked();\n  }\n  /**\n   * Clear\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  async forgetDevice(deviceName) {\n    const keyring = await this.getKeyringForDevice(deviceName);\n    keyring.forgetDevice();\n    return true;\n  }\n  /**\n   * Imports an account from a trezor device.\n   *\n   * @returns {} keyState\n   */\n\n\n  async unlockHardwareWalletAccount(index, deviceName, hdPath) {\n    const keyring = await this.getKeyringForDevice(deviceName, hdPath);\n    keyring.setAccountToUnlock(index);\n    const oldAccounts = await this.keyringController.getAccounts();\n    const keyState = await this.keyringController.addNewAccount(keyring);\n    const newAccounts = await this.keyringController.getAccounts();\n    this.preferencesController.setAddresses(newAccounts);\n    newAccounts.forEach(address => {\n      if (!oldAccounts.includes(address)) {\n        // Select the account\n        this.preferencesController.setSelectedAddress(address);\n      }\n    });\n    this.accountManager.start();\n    const {\n      identities\n    } = this.preferencesController.store.getState();\n    return { ...keyState,\n      identities\n    };\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(DneroWalletController, \"DneroWalletController\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/dnero-wallet.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["_","dnerojs","KeyringController","ComposableObservableStore","PreferencesController","AccountManager","TransactionsController","SimpleKeyring","TrezorKeyring","LedgerKeyring","EthereumDerivationPath","EthereumLedgerLiveDerivationPath","EthereumOtherDerivationPath","NumPathsPerPage","DneroDevDerivationPath","updateAccountBalances","EventEmitter","require","DneroWalletController","constructor","opts","getProvider","provider","setProvider","sendUpdate","_sendUpdate","bind","initState","store","memStore","preferencesController","on","newNetwork","selectedAddress","getSelectedAddress","newProvider","providers","HttpProvider","chainId","accountManager","updateAccounts","updateAccountStakes","detectNewTokens","transactionsController","updateAccountTransactions","network","getNetwork","additionalKeyrings","keyringController","keyringTypes","subscribe","s","_onKeyringVaultUpdate","getTokens","signAndSendTransaction","updateStructure","data","localStorage","setItem","JSON","stringify","pick","e","RPCApi","_setupRPCApi","getState","vault","isInitialized","Boolean","getFlatState","emit","state","keyrings","addresses","reduce","acc","accounts","concat","length","syncAddresses","selectFirstIdentity","identities","address","Object","keys","setSelectedAddress","_getState","addTransactionRequest","_addTransactionRequest","approveTransactionRequest","_approveTransactionRequest","rejectTransactionRequest","_rejectTransactionRequest","addToken","_addToken","removeToken","_removeToken","_setSelectedAddress","setSelectedNetwork","_setSelectedNetwork","importAccount","_importAccount","sendTransaction","_sendTransaction","_updateAccountStakes","_updateAccountBalances","_updateAccountTransactions","connectHardware","forgetDevice","checkHardwareStatus","unlockHardwareWalletAccount","args","transactionRequest","Error","result","transactionRequestId","onDependencySent","token","symbol","decimals","image","setNetwork","importType","privateKey","encryptedJson","encryptedJsonPassword","name","privateKeyToImport","wallet","Wallet","fromEncryptedJson","keyring","addNewKeyring","type","getAccounts","allAccounts","setAddresses","newAccount","setAccountName","start","getKeyringForDevice","deviceName","hdPath","keyringName","getKeyringsByType","setHdPath","page","getPreviousPage","getNextPage","getFirstPage","oldAccounts","accountsToTrack","Set","map","a","toLowerCase","isUnlocked","index","setAccountToUnlock","keyState","addNewAccount","newAccounts","forEach","includes"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/dnero-wallet.js"],"sourcesContent":["import _ from 'lodash';\nimport * as dnerojs from '@dnerolabs/dnero-js';\nimport KeyringController from '../controllers/keyring';\nimport ComposableObservableStore from '../utils/ComposableObservableStore';\nimport PreferencesController from './preferences';\nimport AccountManager from './account-manager';\nimport TransactionsController from './transactions';\nimport SimpleKeyring from '../keyrings/simple';\nimport TrezorKeyring from '../keyrings/trezor';\nimport LedgerKeyring from \"../keyrings/ledger\";\nimport {\n    EthereumDerivationPath, EthereumLedgerLiveDerivationPath,\n    EthereumOtherDerivationPath,\n    NumPathsPerPage,\n    DneroDevDerivationPath\n} from \"../services/Wallet\";\nimport {updateAccountBalances} from \"../state/actions/Wallet\";\n\nconst { EventEmitter } = require('events');\n\nexport default class DneroWalletController extends EventEmitter {\n    constructor(opts) {\n        super();\n\n        this.sendUpdate = this._sendUpdate.bind(this);\n        this.opts = opts;\n\n        const initState = opts.initState || {};\n\n        this.store = new ComposableObservableStore(initState);\n        this.memStore = new ComposableObservableStore();\n\n        this.preferencesController = new PreferencesController({\n            initState: initState.preferencesController\n        });\n        this.preferencesController.on('networkChanged', (newNetwork) => {\n            const selectedAddress = this.preferencesController.getSelectedAddress();\n            const newProvider = new dnerojs.providers.HttpProvider(newNetwork.chainId);\n            this.setProvider(newProvider);\n\n            if(selectedAddress) {\n                this.accountManager.updateAccounts();\n                this.accountManager.updateAccountStakes(selectedAddress);\n                this.accountManager.detectNewTokens();\n\n                this.transactionsController.updateAccountTransactions(selectedAddress);\n            }\n        });\n        this.preferencesController.on('accountTokensUpdated', () => {\n            this.accountManager.updateAccounts();\n        });\n\n        const network = this.preferencesController.getNetwork();\n        this.provider =  new dnerojs.providers.HttpProvider(network.chainId);\n\n        const additionalKeyrings = [TrezorKeyring, LedgerKeyring]\n        this.keyringController = new KeyringController({\n            initState: initState.keyringController,\n            keyringTypes: additionalKeyrings,\n        });\n        this.keyringController.memStore.subscribe((s) =>\n            this._onKeyringVaultUpdate(s),\n        );\n\n        this.accountManager = new AccountManager({\n            getProvider: this.getProvider,\n            getNetwork: this.preferencesController.getNetwork.bind(this.preferencesController),\n            getTokens: this.preferencesController.getTokens.bind(this.preferencesController),\n            preferencesController: this.preferencesController,\n        });\n\n        this.transactionsController = new TransactionsController({\n            initState: initState.transactionsController,\n\n            getProvider: this.getProvider,\n\n            preferencesController: this.preferencesController,\n\n            signAndSendTransaction: this.keyringController.signAndSendTransaction.bind(this.keyringController),\n\n            updateAccounts: this.accountManager.updateAccounts.bind(this.accountManager)\n        });\n\n        this.store.updateStructure({\n            keyringController: this.keyringController.store,\n            preferencesController: this.preferencesController.store,\n        });\n\n        this.preferencesController.store.subscribe((data) => {\n            try {\n                if(localStorage){\n                    localStorage.setItem('preferencesController', JSON.stringify(_.pick(data, 'accountTokens')));\n                }\n            }\n            catch (e) {\n\n            }\n        });\n\n        this.memStore.updateStructure({\n            keyringController: this.keyringController.memStore,\n            preferencesController: this.preferencesController.store,\n            transactionsController: this.transactionsController.memStore,\n            accountManager: this.accountManager.store\n        });\n        this.memStore.subscribe((data) => {\n            this.sendUpdate();\n        });\n\n\n        const sendUpdate = (data) => {\n            // TODO anything?\n        };\n        this.on('update', sendUpdate);\n\n        this.RPCApi = this._setupRPCApi();\n    }\n\n    getProvider = () => {\n        return this.provider;\n    };\n\n    setProvider = (provider) => {\n        this.provider = provider;\n    };\n\n    /**\n     * The dnero-wallet-state of the various controllers, made available to the UI\n     *\n     * @returns {Object} status\n     */\n    getState() {\n        const { vault } = this.keyringController.store.getState();\n        const isInitialized = Boolean(vault);\n\n        return {\n            ...{ isInitialized },\n            ...this.memStore.getFlatState(),\n        };\n    }\n\n    /**\n     * A method for emitting the full Dnero Wallet state to all registered listeners.\n     * @private\n     */\n    _sendUpdate() {\n        this.emit('update', this.getState());\n    }\n\n\n    /**\n     * Handle a KeyringController update\n     * @param {Object} state - the KC state\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _onKeyringVaultUpdate(state) {\n        const { keyrings } = state;\n        const addresses = keyrings.reduce(\n            (acc, { accounts }) => acc.concat(accounts),\n            [],\n        );\n\n        if (!addresses.length) {\n            return;\n        }\n\n        // Ensure preferences + identities controller know about all addresses\n        this.preferencesController.syncAddresses(addresses);\n        this.accountManager.syncAddresses(addresses);\n    }\n\n    /**\n     * Sets the first address in the state to the selected address\n     */\n    async selectFirstIdentity(){\n        const { identities } = this.preferencesController.store.getState();\n        const address = Object.keys(identities)[0];\n        await this.preferencesController.setSelectedAddress(address);\n    }\n\n    _setupRPCApi(){\n        return {\n            getState: this._getState.bind(this),\n\n            // Transactions\n            addTransactionRequest: this._addTransactionRequest.bind(this),\n            approveTransactionRequest: this._approveTransactionRequest.bind(this),\n            rejectTransactionRequest: this._rejectTransactionRequest.bind(this),\n\n            // Tokens\n            addToken: this._addToken.bind(this),\n            removeToken: this._removeToken.bind(this),\n\n            // Preferences\n            setSelectedAddress: this._setSelectedAddress.bind(this),\n            setSelectedNetwork: this._setSelectedNetwork.bind(this),\n\n            // Accounts\n            importAccount: this._importAccount.bind(this),\n\n            sendTransaction: this._sendTransaction.bind(this),\n\n            updateAccountStakes: this._updateAccountStakes.bind(this),\n            updateAccountBalances: this._updateAccountBalances.bind(this),\n            updateAccountTransactions: this._updateAccountTransactions.bind(this),\n\n            // Hardware wallets\n            connectHardware: this.connectHardware.bind(this),\n            forgetDevice: this.forgetDevice.bind(this),\n            checkHardwareStatus: this.checkHardwareStatus.bind(this),\n            unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),\n        };\n    }\n\n\n    async _sendTransaction(args){\n        const {transactionRequest} = args;\n\n        if(!this.getState().isInitialized){\n            throw Error('Your Dnero Wallet has not be initialized.');\n        }\n\n        const result = await this.transactionsController.addTransactionRequest(transactionRequest);\n\n        return result;\n    }\n\n    async _getState(args) {\n        const result = await this.getState();\n\n        return result;\n    }\n\n    async _addTransactionRequest(args) {\n        const {transactionRequest} = args;\n\n        const result = await this.transactionsController.addTransactionRequest(transactionRequest);\n\n        return result;\n    }\n\n    async _approveTransactionRequest(args) {\n        const {transactionRequestId, onDependencySent} = args;\n\n        const result = await this.transactionsController.approveTransactionRequest(transactionRequestId, onDependencySent);\n\n        return result;\n    }\n\n    async _rejectTransactionRequest(args) {\n        const {transactionRequestId} = args;\n\n        const result = await this.transactionsController.rejectTransactionRequest(transactionRequestId);\n\n        return result;\n    }\n\n    async _addToken(args) {\n        const {token} = args;\n        const {address, symbol, decimals, image} = token;\n\n        const result = await this.preferencesController.addToken(address, symbol, decimals, image);\n\n        return result;\n    }\n\n    async _removeToken(args) {\n        const {address} = args;\n\n        const result = await this.preferencesController.removeToken(address);\n\n        return result;\n    }\n\n    async _setSelectedAddress(args) {\n        const {address} = args;\n\n        const result = await this.preferencesController.setSelectedAddress(address);\n\n        return result;\n    }\n\n    async _setSelectedNetwork(args) {\n        const {network} = args;\n\n        const result = await this.preferencesController.setNetwork(network);\n\n        return result;\n    }\n\n    async _importAccount(args) {\n        const {importType, privateKey, encryptedJson, encryptedJsonPassword, name} = args;\n        let privateKeyToImport = null;\n\n        if(privateKey){\n            privateKeyToImport = privateKey;\n        }\n        else if(encryptedJson && encryptedJsonPassword){\n            const wallet = dnerojs.Wallet.fromEncryptedJson(encryptedJson, encryptedJsonPassword, null);\n            privateKeyToImport = wallet.privateKey;\n        }\n        else{\n            throw new Error('Invalid account.');\n        }\n\n        const keyring = await this.keyringController.addNewKeyring(\n            SimpleKeyring.type,\n            [privateKeyToImport],\n        );\n\n        const accounts = await keyring.getAccounts();\n        // update accounts in preferences controller\n        const allAccounts = await this.keyringController.getAccounts();\n        this.preferencesController.setAddresses(allAccounts);\n\n        // Set account name\n        const newAccount = accounts[0];\n        if(newAccount && name){\n            await this.preferencesController.setAccountName(newAccount, name);\n        }\n\n        // set new account as selected\n        await this.preferencesController.setSelectedAddress(newAccount);\n\n        this.accountManager.start();\n\n        return true;\n    }\n\n\n    async _updateAccountStakes(args) {\n        const {address} = args;\n\n        return this.accountManager.updateAccountStakes(address);\n    }\n\n    async _updateAccountBalances(args) {\n        const {} = args;\n\n        return this.accountManager.updateAccounts();\n    }\n\n    async _updateAccountTransactions(args) {\n        const {address} = args;\n\n        return this.transactionsController.updateAccountTransactions(address);\n    }\n\n    //\n    // Hardware\n    //\n\n    async getKeyringForDevice(deviceName, hdPath = null) {\n        let keyringName = null\n        switch (deviceName) {\n            case 'trezor':\n                keyringName = TrezorKeyring.type\n                break\n            case 'ledger':\n                keyringName = LedgerKeyring.type\n                break\n            default:\n                throw new Error(\n                    'DneroWalletController:getKeyringForDevice - Unknown device',\n                )\n        }\n        let keyring = await this.keyringController.getKeyringsByType(keyringName)[0]\n        if (!keyring) {\n            keyring = await this.keyringController.addNewKeyring(keyringName)\n        }\n        if (hdPath && keyring.setHdPath) {\n            // Transform the hdPath so it can be used properly\n            if(hdPath === EthereumDerivationPath){\n                hdPath = EthereumDerivationPath;\n            }\n            else if(hdPath === EthereumOtherDerivationPath){\n                hdPath = EthereumOtherDerivationPath;\n            }\n            else if(hdPath === EthereumLedgerLiveDerivationPath){\n                hdPath = \"m/44'/60'/0'/0/0\";\n            }\n\n            keyring.setHdPath(hdPath)\n        }\n\n        return keyring\n    }\n\n    /**\n     * Fetch account list from a trezor device.\n     *\n     * @returns [] accounts\n     */\n    async connectHardware(deviceName, page, hdPath) {\n        const keyring = await this.getKeyringForDevice(deviceName, hdPath)\n        let accounts = []\n        switch (page) {\n            case -1:\n                accounts = await keyring.getPreviousPage()\n                break\n            case 1:\n                accounts = await keyring.getNextPage()\n                break\n            default:\n                accounts = await keyring.getFirstPage()\n        }\n\n        // Merge with existing accounts\n        // and make sure addresses are not repeated\n        const oldAccounts = await this.keyringController.getAccounts()\n        const accountsToTrack = [\n            ...new Set(\n                oldAccounts.concat(accounts.map((a) => a.address.toLowerCase())),\n            ),\n        ]\n        this.accountManager.syncAddresses(accountsToTrack)\n        return accounts\n    }\n\n    /**\n     * Check if the device is unlocked\n     *\n     * @returns {Promise<boolean>}\n     */\n    async checkHardwareStatus(deviceName, hdPath) {\n        const keyring = await this.getKeyringForDevice(deviceName, hdPath)\n        return keyring.isUnlocked()\n    }\n\n    /**\n     * Clear\n     *\n     * @returns {Promise<boolean>}\n     */\n    async forgetDevice(deviceName) {\n        const keyring = await this.getKeyringForDevice(deviceName)\n        keyring.forgetDevice()\n        return true\n    }\n\n    /**\n     * Imports an account from a trezor device.\n     *\n     * @returns {} keyState\n     */\n    async unlockHardwareWalletAccount(index, deviceName, hdPath) {\n        const keyring = await this.getKeyringForDevice(deviceName, hdPath)\n\n        keyring.setAccountToUnlock(index)\n        const oldAccounts = await this.keyringController.getAccounts()\n        const keyState = await this.keyringController.addNewAccount(keyring)\n        const newAccounts = await this.keyringController.getAccounts()\n        this.preferencesController.setAddresses(newAccounts)\n        newAccounts.forEach((address) => {\n            if (!oldAccounts.includes(address)) {\n                // Select the account\n                this.preferencesController.setSelectedAddress(address)\n            }\n        });\n\n        this.accountManager.start();\n\n        const { identities } = this.preferencesController.store.getState()\n        return { ...keyState, identities }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}