{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _u2fApi = require(\"u2f-api\");\n\nvar _hwTransport = require(\"@ledgerhq/hw-transport\");\n\nvar _hwTransport2 = _interopRequireDefault(_hwTransport);\n\nvar _logs = require(\"@ledgerhq/logs\");\n\nvar _errors = require(\"@ledgerhq/errors\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  var err = new _errors.TransportError(message, id); // $FlowFixMe\n\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu, key) {\n  var result = Buffer.alloc(apdu.length);\n\n  for (var i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n\n  return result;\n} // Convert from normal to web-safe, strip trailing \"=\"s\n\n\nvar webSafe64 = function webSafe64(base64) {\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}; // Convert from web-safe to normal, add trailing \"=\"s\n\n\nvar normal64 = function normal64(base64) {\n  return base64.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"==\".substring(0, 3 * base64.length % 4);\n};\n\nfunction attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {\n  var keyHandle = wrapApdu(apdu, scrambleKey);\n  var challenge = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  var signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  (0, _logs.log)(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return (0, _u2fApi.sign)(signRequest, timeoutMillis / 1000).then(function (response) {\n    var signatureData = response.signatureData;\n\n    if (typeof signatureData === \"string\") {\n      var data = Buffer.from(normal64(signatureData), \"base64\");\n      var result = void 0;\n\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n\n      (0, _logs.log)(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nvar transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(function (t) {\n    return t.emit(\"disconnect\");\n  });\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\n\n\nvar TransportU2F = function (_Transport) {\n  _inherits(TransportU2F, _Transport);\n\n  _createClass(TransportU2F, null, [{\n    key: \"open\",\n\n    /**\n     * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n     */\n\n    /*\n     */\n    value: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_) {\n        var _openTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new TransportU2F());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open(_x) {\n        return _ref.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /*\n     */\n\n  }]);\n\n  function TransportU2F() {\n    _classCallCheck(this, TransportU2F);\n\n    var _this = _possibleConstructorReturn(this, (TransportU2F.__proto__ || Object.getPrototypeOf(TransportU2F)).call(this));\n\n    _this.unwrap = true;\n    transportInstances.push(_this);\n    return _this;\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  _createClass(TransportU2F, [{\n    key: \"exchange\",\n    value: function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(apdu) {\n        var isU2FError;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n                isU2FError = _typeof(_context2.t0.metaData) === \"object\";\n\n                if (!isU2FError) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                if (isTimeoutU2FError(_context2.t0)) {\n                  emitDisconnect();\n                } // the wrapping make error more usable and \"printable\" to the end user.\n\n\n                throw wrapU2FTransportError(_context2.t0, \"Failed to sign with Ledger device: U2F \" + _context2.t0.metaData.type, \"U2F_\" + _context2.t0.metaData.code);\n\n              case 14:\n                throw _context2.t0;\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n\n      function exchange(_x3) {\n        return _ref2.apply(this, arguments);\n      }\n\n      return exchange;\n    }()\n    /**\n     */\n\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey(scrambleKey) {\n      this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n    }\n    /**\n     */\n\n  }, {\n    key: \"setUnwrap\",\n    value: function setUnwrap(unwrap) {\n      this.unwrap = unwrap;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      // u2f have no way to clean things up\n      return Promise.resolve();\n    }\n  }]);\n\n  return TransportU2F;\n}(_hwTransport2.default);\n\nTransportU2F.isSupported = _u2fApi.isSupported;\n\nTransportU2F.list = function () {\n  return (// this transport is not discoverable but we are going to guess if it is here with isSupported()\n    (0, _u2fApi.isSupported)().then(function (supported) {\n      return supported ? [null] : [];\n    })\n  );\n};\n\nTransportU2F.listen = function (observer) {\n  var unsubscribed = false;\n  (0, _u2fApi.isSupported)().then(function (supported) {\n    if (unsubscribed) return;\n\n    if (supported) {\n      observer.next({\n        type: \"add\",\n        descriptor: null\n      });\n      observer.complete();\n    } else {\n      observer.error(new _errors.TransportError(\"U2F browser support is needed for Ledger. \" + \"Please use Chrome, Opera or Firefox with a U2F extension. \" + \"Also make sure you're on an HTTPS connection\", \"U2FNotSupported\"));\n    }\n  });\n  return {\n    unsubscribe: function unsubscribe() {\n      unsubscribed = true;\n    }\n  };\n};\n\nexports.default = TransportU2F;","map":{"version":3,"sources":["../src/TransportU2F.js"],"names":["err","result","Buffer","apdu","i","key","webSafe64","base64","normal64","keyHandle","wrapApdu","challenge","signRequest","version","appId","location","origin","timeoutMillis","signatureData","response","data","transportInstances","t","u2fError","TransportU2F","isSupported","list","supported","listen","unsubscribed","observer","type","descriptor","unsubscribe","unwrap","_","_openTimeout","attemptExchange","isU2FError","isTimeoutU2FError","emitDisconnect","wrapU2FTransportError","scrambleKey","Promise"],"mappings":"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","sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then(response => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(t => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then(supported => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then(supported => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      }\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}