{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport _ from 'lodash';\nimport * as dnerojs from '@dnerolabs/dnero-js';\nimport BigNumber from 'bignumber.js';\nimport ObservableStore from '../utils/ObservableStore';\nimport { SingleCallTokenBalancesAddressByChainId, DDropStakingAddressByChainId } from '../constants';\nimport { SingleCallTokenBalancesABI, DDropStakingABI } from '../constants/contracts';\n\nconst {\n  tokensByChainId\n} = require('@dnerolabs/dnc20-contract-metadata');\n\nconst DEFAULT_INTERVAL = 60 * 1000;\n/**\n * This module is responsible for tracking any number of accounts and caching their current balances & transaction\n * counts.\n *\n * It also tracks transaction hashes, and checks their inclusion status on each new block.\n *\n * @typedef {Object} AccountManager\n * @property {Object} store The stored object containing all accounts to track\n * @property {Object} store.accounts The accounts currently stored in this AccountTracker\n *\n */\n\nexport default class AccountManager {\n  /**\n   * @param {Object} opts - Options for initializing the controller\n   */\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const initState = {\n      accounts: {}\n    };\n    this.store = new ObservableStore(initState);\n    this._getProvider = opts.getProvider;\n    this._getNetwork = opts.getNetwork;\n    this._getTokens = opts.getTokens;\n    this._preferencesController = opts.preferencesController;\n    this._updateIntervalId = null;\n  }\n\n  start() {\n    // fetch account balances\n    this.updateAccounts();\n\n    if (!this._updateIntervalId) {\n      this._updateIntervalId = setInterval(() => {\n        this.updateAccounts();\n      }, DEFAULT_INTERVAL);\n    }\n\n    this.detectNewTokens();\n  }\n\n  stop() {\n    if (this._updateIntervalId) {\n      clearInterval(this._updateIntervalId);\n    }\n  }\n  /**\n   * Ensures that the locally stored accounts are in sync with a set of accounts stored externally to this\n   * AccountTracker.\n   *\n   * Once this AccountTracker's accounts are up to date with those referenced by the passed addresses, each\n   * of these accounts are given an updated balance via EthQuery.\n   *\n   * @param {Array} addresses - The array of hex addresses for accounts with which this AccountTracker's accounts should be\n   * in sync\n   *\n   */\n\n\n  syncAddresses(addresses) {\n    const {\n      accounts\n    } = this.store.getState();\n    const locals = Object.keys(accounts);\n    const accountsToAdd = [];\n    addresses.forEach(addr => {\n      if (!locals.includes(addr)) {\n        accountsToAdd.push(addr);\n      }\n    });\n    const accountsToRemove = [];\n    locals.forEach(local => {\n      if (!addresses.includes(local)) {\n        accountsToRemove.push(local);\n      }\n    });\n    this.addAccounts(accountsToAdd);\n    this.removeAccounts(accountsToRemove);\n  }\n  /**\n   * Adds new addresses to track the balances of\n   * given a balance as long this._currentBlockNumber is defined.\n   *\n   * @param {Array} addresses - An array of hex addresses of new accounts to track\n   *\n   */\n\n\n  addAccounts(addresses) {\n    const {\n      accounts\n    } = this.store.getState(); // add initial state for addresses\n\n    addresses.forEach(address => {\n      accounts[address] = {};\n    }); // save accounts state\n\n    this.store.updateState({\n      accounts\n    }); // fetch balances for the accounts that we added\n\n    if (addresses.length) {\n      this.updateAccounts();\n    }\n  }\n  /**\n   * Removes accounts from being tracked\n   *\n   * @param {Array} addresses - array of hex addresses to stop tracking\n   *\n   */\n\n\n  removeAccounts(addresses) {\n    const {\n      accounts\n    } = this.store.getState(); // remove each state object\n\n    addresses.forEach(address => {\n      delete accounts[address];\n    }); // save accounts state\n\n    this.store.updateState({\n      accounts\n    });\n  }\n  /**\n   * Removes all addresses and associated balances\n   */\n\n\n  clearAccounts() {\n    this.store.updateState({\n      accounts: {}\n    });\n  }\n  /**\n   * balanceChecker is deployed on main eth (test)nets and requires a single call\n   * for all other networks, calls this._updateAccount for each account in this.store\n   *\n   * @returns {Promise} after all account balances updated\n   *\n   */\n\n\n  async updateAccounts() {\n    const {\n      accounts\n    } = this.store.getState();\n    const addresses = Object.keys(accounts);\n\n    if (addresses.length === 0) {\n      // No accounts to fetch\n      return true;\n    }\n\n    addresses.map(addr => {\n      this._updateAccount(addr);\n    }); // Fetch tokens...\n\n    await this._updateAccountTokensViaBalanceChecker(addresses);\n  }\n  /**\n   * Updates the current balance of an account.\n   *\n   * @private\n   * @param {string} address - A hex address of a the account to be updated\n   * @returns {Promise} after the account balance is updated\n   *\n   */\n\n\n  async _updateAccount(address) {\n    // query balance\n    let account = null;\n\n    try {\n      const provider = this._getProvider();\n\n      account = await provider.getAccount(address);\n    } catch (e) {\n      // This can happen if the account doesn't have any dnero/dtoken yet.\n      account = {\n        coins: {\n          dnerowei: 0,\n          dtokenwei: 0\n        }\n      };\n    }\n\n    const result = {\n      address: address,\n      balances: account.coins\n    }; // update accounts state\n\n    const {\n      accounts\n    } = this.store.getState();\n    const current = accounts[address.toLowerCase()] || accounts[address] || {}; // only populate if the entry is still present\n\n    accounts[address] = { // keep our stakes\n      ...current,\n      ...result,\n      balances: { ...current.balances,\n        ...result.balances\n      }\n    };\n    this.store.updateState({\n      accounts\n    });\n  }\n  /**\n   * Updates current address balances from balanceChecker deployed contract instance\n   * @param {*} addresses\n   * @param {*} deployedContractAddress\n   */\n\n\n  async _updateAccountTokensViaBalanceChecker(addresses) {\n    const {\n      accounts\n    } = this.store.getState();\n\n    const provider = this._getProvider();\n\n    const chainId = this._getNetwork().chainId;\n\n    const tokens = this._getTokens();\n\n    let tokenAddresses = _.map(tokens, 'address');\n\n    tokenAddresses = _.map(tokenAddresses, _.trim);\n    const deployedContractAddress = SingleCallTokenBalancesAddressByChainId[chainId];\n\n    if (_.isNil(deployedContractAddress)) {\n      // TODO not supported... call each token?\n      return;\n    }\n\n    if (tokenAddresses.length === 0) {\n      // No tokens to fetch\n      return;\n    }\n\n    if (addresses.length === 0) {\n      // No addresses to fetch\n      return;\n    }\n\n    try {\n      const balanceCheckContract = new dnerojs.Contract(deployedContractAddress, SingleCallTokenBalancesABI, provider);\n      const balances = await balanceCheckContract.balances(addresses, tokenAddresses); // contract returns a array of length addresses.length * tokens.length so we need to partiton it\n\n      const balancesGroupedByAddress = _.chunk(balances, tokenAddresses.length);\n\n      addresses.forEach((address, index) => {\n        const addressTokenBalances = balancesGroupedByAddress[index];\n\n        const tokenBalancesByTokenAddress = _.reduce(addressTokenBalances, function (current, balance, tokenIdx) {\n          const tokenAddress = tokenAddresses[tokenIdx];\n          return Object.assign(current, {\n            [tokenAddress]: balance.toString()\n          });\n        }, {});\n\n        const currentAccounts = this.store.getState().accounts;\n        const currentBalances = currentAccounts[address].balances;\n        const current = accounts[address.toLowerCase()] || accounts[address];\n        accounts[address] = { ...current,\n          address,\n          balances: { ...currentBalances,\n            ...tokenBalancesByTokenAddress\n          }\n        };\n      });\n      this.store.updateState({\n        accounts\n      });\n    } catch (e) {}\n  }\n\n  async updateAccountDDropStake(address) {\n    let stakingBalance = new BigNumber(0);\n    let totalShares = new BigNumber(0);\n    let estimatedDDropOwned = new BigNumber(0);\n    let delegate = null;\n\n    try {\n      const provider = this._getProvider();\n\n      const network = this._getNetwork();\n\n      const chainId = network.chainId;\n      const deployedContractAddress = DDropStakingAddressByChainId[chainId];\n\n      if (_.isNil(deployedContractAddress)) {\n        return null;\n      }\n\n      const ddropStakingContract = new dnerojs.Contract(deployedContractAddress, DDropStakingABI, provider);\n      stakingBalance = await ddropStakingContract.balanceOf(address);\n\n      if (!stakingBalance.isZero()) {\n        estimatedDDropOwned = await ddropStakingContract.estimatedDDropOwnedBy(address);\n        totalShares = await ddropStakingContract.totalShares();\n        delegate = await ddropStakingContract.delegates(address);\n      }\n    } catch (e) {\n      // No Update\n      return null;\n    } // update accounts state\n\n\n    const {\n      accounts\n    } = this.store.getState();\n    const current = accounts[address.toLowerCase()] || accounts[address]; // only populate if the entry is still present\n\n    if (!current) {\n      return null;\n    }\n\n    const votingPower = new BigNumber(stakingBalance.toString()).dividedBy(new BigNumber(totalShares.toString())).multipliedBy(100);\n    const ddropStakingInfo = {\n      balance: stakingBalance.toString(),\n      totalShares: totalShares.toString(),\n      estimatedTokenOwnedWithRewards: estimatedDDropOwned.toString(),\n      votingPower: stakingBalance.isZero() ? \"0\" : votingPower.toString(),\n      votingDelegate: delegate\n    };\n    accounts[address] = { ...current,\n      dnc20Stakes: {\n        ddrop: ddropStakingInfo\n      }\n    };\n    this.store.updateState({\n      accounts\n    });\n    return ddropStakingInfo;\n  }\n\n  async updateAccountStakes(address) {\n    let stakes = null;\n\n    try {\n      const network = this._getNetwork();\n\n      const chainId = network.chainId;\n      const explorerUrl = dnerojs.networks.getExplorerUrlForChainId(chainId);\n      const explorerApiUrl = `${explorerUrl}:8443/api`;\n      const listStakesUrl = `${explorerApiUrl}/stake/${address}?hasBalance=true&types[]=vcp&types[]=gcp&types[]=eenp`;\n      const response = await fetch(listStakesUrl);\n      const responseJson = await response.json();\n      stakes = _.get(responseJson, ['body', 'sourceRecords'], []);\n    } catch (e) {\n      // No Update\n      return [];\n    } // update accounts state\n\n\n    const {\n      accounts\n    } = this.store.getState();\n    const current = accounts[address.toLowerCase()] || accounts[address]; // only populate if the entry is still present\n\n    if (!current) {\n      return [];\n    }\n\n    accounts[address] = { ...current,\n      stakes: stakes\n    };\n    this.store.updateState({\n      accounts\n    }); // DNC20 stakes\n\n    await this.updateAccountDDropStake(address);\n    return stakes;\n  }\n\n  async detectNewTokens() {\n    const selectedAddress = this._preferencesController.getSelectedAddress();\n\n    const provider = this._getProvider();\n\n    const network = this._getNetwork();\n\n    const chainId = network.chainId;\n    const knownTokenList = tokensByChainId[chainId];\n\n    const tokens = this._getTokens();\n\n    let tokenAddresses = _.map(tokens, 'address');\n\n    let trackedTokens = new Set(_.map(tokenAddresses, _.trim));\n    const tokensToDetect = [];\n\n    for (const tokenAddress in knownTokenList) {\n      if (!trackedTokens.has(tokenAddress)) {\n        tokensToDetect.push(tokenAddress);\n      }\n    }\n\n    if (tokensToDetect.length === 0) {\n      return;\n    }\n\n    const sliceOfTokensToDetect = [tokensToDetect.slice(0, 1000), tokensToDetect.slice(1000, tokensToDetect.length - 1)];\n    const balanceCheckContract = new dnerojs.Contract(SingleCallTokenBalancesAddressByChainId[chainId], SingleCallTokenBalancesABI, provider);\n\n    for (const tokensSlice of sliceOfTokensToDetect) {\n      let result;\n\n      try {\n        result = await balanceCheckContract.balances([selectedAddress], tokensSlice);\n      } catch (error) {\n        return;\n      }\n\n      const tokensWithBalance = tokensSlice.filter((_, index) => {\n        const balance = result[index];\n        return balance && !balance.isZero();\n      });\n      await Promise.all(tokensWithBalance.map(tokenAddress => {\n        return this._preferencesController.addToken(tokenAddress, knownTokenList[tokenAddress].symbol, knownTokenList[tokenAddress].decimals);\n      }));\n    }\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(DEFAULT_INTERVAL, \"DEFAULT_INTERVAL\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/account-manager.js\");\n  reactHotLoader.register(AccountManager, \"AccountManager\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/account-manager.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["_","dnerojs","BigNumber","ObservableStore","SingleCallTokenBalancesAddressByChainId","DDropStakingAddressByChainId","SingleCallTokenBalancesABI","DDropStakingABI","tokensByChainId","require","DEFAULT_INTERVAL","AccountManager","constructor","opts","initState","accounts","store","_getProvider","getProvider","_getNetwork","getNetwork","_getTokens","getTokens","_preferencesController","preferencesController","_updateIntervalId","start","updateAccounts","setInterval","detectNewTokens","stop","clearInterval","syncAddresses","addresses","getState","locals","Object","keys","accountsToAdd","forEach","addr","includes","push","accountsToRemove","local","addAccounts","removeAccounts","address","updateState","length","clearAccounts","map","_updateAccount","_updateAccountTokensViaBalanceChecker","account","provider","getAccount","e","coins","dnerowei","dtokenwei","result","balances","current","toLowerCase","chainId","tokens","tokenAddresses","trim","deployedContractAddress","isNil","balanceCheckContract","Contract","balancesGroupedByAddress","chunk","index","addressTokenBalances","tokenBalancesByTokenAddress","reduce","balance","tokenIdx","tokenAddress","assign","toString","currentAccounts","currentBalances","updateAccountDDropStake","stakingBalance","totalShares","estimatedDDropOwned","delegate","network","ddropStakingContract","balanceOf","isZero","estimatedDDropOwnedBy","delegates","votingPower","dividedBy","multipliedBy","ddropStakingInfo","estimatedTokenOwnedWithRewards","votingDelegate","dnc20Stakes","ddrop","updateAccountStakes","stakes","explorerUrl","networks","getExplorerUrlForChainId","explorerApiUrl","listStakesUrl","response","fetch","responseJson","json","get","selectedAddress","getSelectedAddress","knownTokenList","trackedTokens","Set","tokensToDetect","has","sliceOfTokensToDetect","slice","tokensSlice","error","tokensWithBalance","filter","Promise","all","addToken","symbol","decimals"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/account-manager.js"],"sourcesContent":["import _ from 'lodash';\nimport * as dnerojs from '@dnerolabs/dnero-js';\nimport BigNumber from 'bignumber.js';\nimport ObservableStore from '../utils/ObservableStore';\nimport {SingleCallTokenBalancesAddressByChainId, DDropStakingAddressByChainId} from '../constants';\nimport {SingleCallTokenBalancesABI, DDropStakingABI} from '../constants/contracts';\n\nconst {tokensByChainId} = require('@dnerolabs/dnc20-contract-metadata');\nconst DEFAULT_INTERVAL = 60 * 1000;\n\n/**\n * This module is responsible for tracking any number of accounts and caching their current balances & transaction\n * counts.\n *\n * It also tracks transaction hashes, and checks their inclusion status on each new block.\n *\n * @typedef {Object} AccountManager\n * @property {Object} store The stored object containing all accounts to track\n * @property {Object} store.accounts The accounts currently stored in this AccountTracker\n *\n */\nexport default class AccountManager {\n    /**\n     * @param {Object} opts - Options for initializing the controller\n     */\n    constructor(opts = {}) {\n        const initState = {\n            accounts: {}\n        };\n        this.store = new ObservableStore(initState);\n        this._getProvider = opts.getProvider;\n        this._getNetwork = opts.getNetwork;\n        this._getTokens = opts.getTokens;\n        this._preferencesController = opts.preferencesController;\n        this._updateIntervalId = null;\n    }\n\n    start() {\n        // fetch account balances\n        this.updateAccounts();\n\n        if(!this._updateIntervalId){\n            this._updateIntervalId = setInterval(() => {\n                this.updateAccounts();\n            }, DEFAULT_INTERVAL);\n        }\n\n        this.detectNewTokens();\n    }\n\n    stop() {\n        if(this._updateIntervalId){\n            clearInterval(this._updateIntervalId);\n        }\n    }\n\n    /**\n     * Ensures that the locally stored accounts are in sync with a set of accounts stored externally to this\n     * AccountTracker.\n     *\n     * Once this AccountTracker's accounts are up to date with those referenced by the passed addresses, each\n     * of these accounts are given an updated balance via EthQuery.\n     *\n     * @param {Array} addresses - The array of hex addresses for accounts with which this AccountTracker's accounts should be\n     * in sync\n     *\n     */\n    syncAddresses(addresses) {\n        const { accounts } = this.store.getState();\n        const locals = Object.keys(accounts);\n\n        const accountsToAdd = [];\n        addresses.forEach((addr) => {\n            if (!locals.includes(addr)) {\n                accountsToAdd.push(addr);\n            }\n        });\n\n        const accountsToRemove = [];\n        locals.forEach((local) => {\n            if (!addresses.includes(local)) {\n                accountsToRemove.push(local);\n            }\n        });\n\n        this.addAccounts(accountsToAdd);\n        this.removeAccounts(accountsToRemove);\n    }\n\n    /**\n     * Adds new addresses to track the balances of\n     * given a balance as long this._currentBlockNumber is defined.\n     *\n     * @param {Array} addresses - An array of hex addresses of new accounts to track\n     *\n     */\n    addAccounts(addresses) {\n        const { accounts } = this.store.getState();\n        // add initial state for addresses\n        addresses.forEach((address) => {\n            accounts[address] = {};\n        });\n        // save accounts state\n        this.store.updateState({ accounts });\n\n        // fetch balances for the accounts that we added\n        if(addresses.length){\n            this.updateAccounts();\n        }\n    }\n\n    /**\n     * Removes accounts from being tracked\n     *\n     * @param {Array} addresses - array of hex addresses to stop tracking\n     *\n     */\n    removeAccounts(addresses) {\n        const { accounts } = this.store.getState();\n        // remove each state object\n        addresses.forEach((address) => {\n            delete accounts[address];\n        });\n        // save accounts state\n        this.store.updateState({ accounts });\n    }\n\n    /**\n     * Removes all addresses and associated balances\n     */\n\n    clearAccounts() {\n        this.store.updateState({ accounts: {} });\n    }\n\n    /**\n     * balanceChecker is deployed on main eth (test)nets and requires a single call\n     * for all other networks, calls this._updateAccount for each account in this.store\n     *\n     * @returns {Promise} after all account balances updated\n     *\n     */\n    async updateAccounts() {\n        const { accounts } = this.store.getState();\n        const addresses = Object.keys(accounts);\n\n        if(addresses.length === 0){\n            // No accounts to fetch\n            return true;\n        }\n\n        addresses.map((addr) => {\n            this._updateAccount(addr);\n        });\n\n        // Fetch tokens...\n        await this._updateAccountTokensViaBalanceChecker(addresses);\n    }\n\n    /**\n     * Updates the current balance of an account.\n     *\n     * @private\n     * @param {string} address - A hex address of a the account to be updated\n     * @returns {Promise} after the account balance is updated\n     *\n     */\n    async _updateAccount(address) {\n        // query balance\n        let account = null;\n        try {\n            const provider = this._getProvider();\n\n            account = await provider.getAccount(address);\n        }\n        catch (e) {\n            // This can happen if the account doesn't have any dnero/dtoken yet.\n            account = {\n                coins: {\n                    dnerowei: 0,\n                    dtokenwei: 0,\n                }\n            };\n        }\n\n        const result = {\n            address: address,\n            balances: account.coins,\n        };\n\n        // update accounts state\n        const { accounts } = this.store.getState();\n        const current = accounts[address.toLowerCase()] || accounts[address] || {};\n        // only populate if the entry is still present\n\n        accounts[address] = {\n            // keep our stakes\n            ...current,\n            ...result,\n            balances: {\n                ...current.balances,\n                ...result.balances\n            }\n        };\n        this.store.updateState({ accounts });\n    }\n\n    /**\n     * Updates current address balances from balanceChecker deployed contract instance\n     * @param {*} addresses\n     * @param {*} deployedContractAddress\n     */\n    async _updateAccountTokensViaBalanceChecker(addresses) {\n        const { accounts } = this.store.getState();\n        const provider = this._getProvider();\n        const chainId = this._getNetwork().chainId;\n        const tokens = this._getTokens();\n        let tokenAddresses = _.map(tokens, 'address');\n        tokenAddresses = _.map(tokenAddresses, _.trim);\n        const deployedContractAddress = SingleCallTokenBalancesAddressByChainId[chainId];\n\n        if(_.isNil(deployedContractAddress)){\n            // TODO not supported... call each token?\n            return;\n        }\n\n        if(tokenAddresses.length === 0){\n            // No tokens to fetch\n            return;\n        }\n\n        if(addresses.length === 0){\n            // No addresses to fetch\n            return;\n        }\n\n        try {\n            const balanceCheckContract = new dnerojs.Contract(deployedContractAddress, SingleCallTokenBalancesABI, provider);\n            const balances = await balanceCheckContract.balances(addresses, tokenAddresses);\n            // contract returns a array of length addresses.length * tokens.length so we need to partiton it\n            const balancesGroupedByAddress = _.chunk(balances, tokenAddresses.length);\n\n            addresses.forEach((address, index) => {\n                const addressTokenBalances = balancesGroupedByAddress[index];\n                const tokenBalancesByTokenAddress = _.reduce(addressTokenBalances, function(current, balance, tokenIdx) {\n                    const tokenAddress = tokenAddresses[tokenIdx];\n                    return Object.assign(current, {\n                        [tokenAddress]: balance.toString()\n                    });\n                }, {});\n                const currentAccounts = this.store.getState().accounts;\n                const currentBalances = currentAccounts[address].balances;\n                const current = accounts[address.toLowerCase()] || accounts[address];\n\n                accounts[address] = {\n                    ...current,\n                    address,\n                    balances: {\n                        ...currentBalances,\n                        ...tokenBalancesByTokenAddress\n                    }};\n            });\n\n            this.store.updateState({ accounts });\n        }\n        catch (e) {\n\n        }\n    }\n\n    async updateAccountDDropStake(address){\n        let stakingBalance = new BigNumber(0);\n        let totalShares = new BigNumber(0);\n        let estimatedDDropOwned = new BigNumber(0);\n        let delegate = null;\n\n        try {\n            const provider = this._getProvider();\n            const network = this._getNetwork();\n            const chainId = network.chainId;\n            const deployedContractAddress = DDropStakingAddressByChainId[chainId];\n            if(_.isNil(deployedContractAddress)){\n                return null;\n            }\n            const ddropStakingContract = new dnerojs.Contract(deployedContractAddress, DDropStakingABI, provider);\n            stakingBalance = await ddropStakingContract.balanceOf(address);\n\n            if(!stakingBalance.isZero()){\n                estimatedDDropOwned = await ddropStakingContract.estimatedDDropOwnedBy(address);\n                totalShares = await ddropStakingContract.totalShares();\n                delegate = await ddropStakingContract.delegates(address);\n            }\n        }\n        catch (e) {\n            // No Update\n            return null;\n        }\n\n        // update accounts state\n        const { accounts } = this.store.getState();\n        const current = accounts[address.toLowerCase()] || accounts[address];\n        // only populate if the entry is still present\n        if (!current) {\n            return null;\n        }\n\n        const votingPower = ((new BigNumber(stakingBalance.toString())).dividedBy((new BigNumber(totalShares.toString())))).multipliedBy(100);\n        const ddropStakingInfo = {\n            balance: stakingBalance.toString(),\n            totalShares: totalShares.toString(),\n            estimatedTokenOwnedWithRewards: estimatedDDropOwned.toString(),\n            votingPower: stakingBalance.isZero() ? \"0\" : votingPower.toString(),\n            votingDelegate: delegate\n        };\n\n        accounts[address] = {\n            ...current,\n            dnc20Stakes: {\n                ddrop: ddropStakingInfo\n            }\n        };\n        this.store.updateState({ accounts });\n\n        return ddropStakingInfo;\n    }\n\n    async updateAccountStakes(address){\n        let stakes = null;\n\n        try {\n            const network = this._getNetwork();\n            const chainId = network.chainId;\n            const explorerUrl = dnerojs.networks.getExplorerUrlForChainId(chainId);\n            const explorerApiUrl = `${explorerUrl}:8443/api`;\n            const listStakesUrl = `${explorerApiUrl}/stake/${address}?hasBalance=true&types[]=vcp&types[]=gcp&types[]=eenp`;\n            const response = await fetch(listStakesUrl);\n            const responseJson = await response.json();\n            stakes = _.get(responseJson, ['body', 'sourceRecords'], []);\n        }\n        catch (e) {\n            // No Update\n            return [];\n        }\n\n        // update accounts state\n        const { accounts } = this.store.getState();\n        const current = accounts[address.toLowerCase()] || accounts[address];\n        // only populate if the entry is still present\n        if (!current) {\n            return [];\n        }\n        accounts[address] = {\n            ...current,\n            stakes: stakes\n        };\n        this.store.updateState({ accounts });\n\n        // DNC20 stakes\n        await this.updateAccountDDropStake(address);\n\n        return stakes;\n    }\n\n    async detectNewTokens() {\n        const selectedAddress = this._preferencesController.getSelectedAddress();\n        const provider = this._getProvider();\n        const network = this._getNetwork();\n        const chainId = network.chainId;\n        const knownTokenList = tokensByChainId[chainId];\n        const tokens = this._getTokens();\n        let tokenAddresses = _.map(tokens, 'address');\n        let trackedTokens = new Set(_.map(tokenAddresses, _.trim));\n\n        const tokensToDetect = [];\n        for (const tokenAddress in knownTokenList) {\n            if (!trackedTokens.has(tokenAddress)) {\n                tokensToDetect.push(tokenAddress);\n            }\n        }\n\n        if(tokensToDetect.length === 0){\n            return;\n        }\n\n        const sliceOfTokensToDetect = [\n            tokensToDetect.slice(0, 1000),\n            tokensToDetect.slice(1000, tokensToDetect.length - 1),\n        ];\n        const balanceCheckContract = new dnerojs.Contract(SingleCallTokenBalancesAddressByChainId[chainId], SingleCallTokenBalancesABI, provider);\n\n        for (const tokensSlice of sliceOfTokensToDetect) {\n            let result;\n            try {\n                result = await balanceCheckContract.balances([selectedAddress], tokensSlice);\n            } catch (error) {\n                return;\n            }\n\n            const tokensWithBalance = tokensSlice.filter((_, index) => {\n                const balance = result[index];\n                return balance && !balance.isZero();\n            });\n\n            await Promise.all(\n                tokensWithBalance.map((tokenAddress) => {\n                    return this._preferencesController.addToken(\n                        tokenAddress,\n                        knownTokenList[tokenAddress].symbol,\n                        knownTokenList[tokenAddress].decimals,\n                    );\n                }),\n            );\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}