{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport ObservableStore from '../utils/ObservableStore';\nimport SimpleKeyring from '../keyrings/simple/index';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst keyringTypes = [SimpleKeyring];\nexport default class KeyringController extends EventEmitter {\n  //\n  // PUBLIC METHODS\n  //\n  constructor(opts) {\n    super();\n    const initState = opts.initState || {};\n    this.store = new ObservableStore(initState);\n    this.keyringTypes = opts.keyringTypes ? keyringTypes.concat(opts.keyringTypes) : keyringTypes;\n    this.memStore = new ObservableStore({\n      isUnlocked: false,\n      keyringTypes: this.keyringTypes.map(krt => krt.type),\n      keyrings: []\n    });\n    this.keyrings = [];\n  }\n  /**\n   * Full Update\n   *\n   * Emits the `update` event and @returns a Promise that resolves to\n   * the current state.\n   *\n   * Frequently used to end asynchronous chains in this class,\n   * indicating consumers can often either listen for updates,\n   * or accept a state-resolving promise to consume their results.\n   *\n   * @returns {Object} The controller state.\n   */\n\n\n  fullUpdate() {\n    this.emit('update', this.memStore.getState());\n    return this.memStore.getState();\n  }\n  /**\n   * Update Memstore Keyrings\n   *\n   * Updates the in-memory keyrings, without persisting.\n   */\n\n\n  async _updateMemStoreKeyrings() {\n    const keyrings = await Promise.all(this.keyrings.map(this._dataForKeyring));\n    return this.memStore.updateState({\n      keyrings\n    });\n  }\n  /**\n   * Add New Keyring\n   *\n   * Adds a new Keyring of the given `type` to the vault\n   * and the current decrypted Keyrings array.\n   *\n   * All Keyring classes implement a unique `type` string,\n   * and this is used to retrieve them from the keyringTypes array.\n   *\n   * @param {string} type - The type of keyring to add.\n   * @param {Object} opts - The constructor options for the keyring.\n   * @returns {Promise<SimpleKeyring|HDKeyring>} The new keyring.\n   */\n\n\n  addNewKeyring(type, opts) {\n    const Keyring = this._getKeyringClassForType(type);\n\n    const keyring = new Keyring(opts);\n    return keyring.getAccounts().then(() => {\n      this.keyrings.push(keyring);\n    }).then(() => this._updateMemStoreKeyrings()).then(() => this.fullUpdate()).then(() => {\n      return keyring;\n    });\n  }\n  /**\n   * Get Accounts\n   *\n   * Returns the public addresses of all current accounts\n   * managed by all currently unlocked keyrings.\n   *\n   * @returns {Promise<Array<string>>} The array of accounts.\n   */\n\n\n  async getAccounts() {\n    const keyrings = this.keyrings || [];\n    const addresses = await Promise.all(keyrings.map(kr => kr.getAccounts())).then(keyringArrays => {\n      return keyringArrays.reduce((res, arr) => {\n        return res.concat(arr);\n      }, []);\n    });\n    return addresses;\n  }\n  /**\n   * Add New Account\n   *\n   * Calls the `addAccounts` method on the given keyring,\n   * and then saves those changes.\n   *\n   * @param {SimpleKeyring|HDKeyring} selectedKeyring - The currently selected keyring.\n   * @returns {Promise<Object>} A Promise that resolves to the state.\n   */\n\n\n  async addNewAccount(selectedKeyring) {\n    const addedAccounts = await selectedKeyring.addAccounts(1);\n    addedAccounts.forEach(address => {\n      this.emit('newAccount', address);\n    });\n    await this._updateMemStoreKeyrings();\n    return await this.fullUpdate();\n  }\n  /**\n   * Get Keyrings by Type\n   *\n   * Gets all keyrings of the given type.\n   *\n   * @param {string} type - The keyring types to retrieve.\n   * @returns {Array<SimpleKeyring|HDKeyring>} The keyrings.\n   */\n\n\n  getKeyringsByType(type) {\n    return this.keyrings.filter(keyring => keyring.type === type);\n  }\n  /**\n   * Get Keyrings by Type\n   *\n   * Gets all keyrings of the given type.\n   *\n   * @param {string} type - The keyring types to retrieve.\n   * @returns {SimpleKeyring|HDKeyring} The keyrings.\n   */\n\n\n  getPrimaryKeyring() {\n    // Only supports one account for now\n    return this.keyrings[0];\n  } //\n  // SIGNING METHODS\n  //\n\n  /**\n   * Sign Dnero Transaction\n   *\n   * Signs a Dnero transaction object.\n   *\n   * @param {string} fromAddress - The transaction 'from' address.\n   * @param {Object} txJson - The dnero transaction (JSON format) to sign.\n   * @returns {Promise<Object>} The signed transaction bytes.\n   */\n\n\n  signTransaction(fromAddress, txJson) {\n    return this._getKeyringForAccount(fromAddress).then(keyring => {\n      return keyring.signTransaction(fromAddress, txJson);\n    });\n  }\n\n  signAndSendTransaction(fromAddress, transaction, networkChainId) {\n    return this._getKeyringForAccount(fromAddress).then(keyring => {\n      return keyring.signAndSendTransaction(fromAddress, transaction, networkChainId);\n    });\n  } //\n  // PRIVATE METHODS\n  //\n\n  /**\n   * Get Keyring Class For Type\n   *\n   * Searches the current `keyringTypes` array\n   * for a Keyring class whose unique `type` property\n   * matches the provided `type`,\n   * returning it if it exists.\n   *\n   * @param {string} type - The type whose class to get.\n   * @returns {SimpleKeyring|HdKeyring} The class, if it exists.\n   */\n\n\n  _getKeyringClassForType(type) {\n    return this.keyringTypes.find(kr => kr.type === type);\n  }\n  /**\n   * Get Keyring For Account\n   *\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @param {string} address - An account address.\n   * @returns {Promise<SimpleKeyring|HDKeyring>} The keyring of the account, if it exists.\n   */\n\n\n  _getKeyringForAccount(address) {\n    return Promise.all(this.keyrings.map(keyring => {\n      return Promise.all([keyring, keyring.getAccounts()]);\n    })).then(candidates => {\n      const winners = candidates.filter(candidate => {\n        const accounts = candidate[1];\n        return accounts.includes(address);\n      });\n\n      if (winners && winners.length > 0) {\n        return winners[0][0];\n      }\n\n      throw new Error('No keyring found for the requested account.');\n    });\n  }\n  /**\n   * Display For Keyring\n   *\n   * Is used for adding the current keyrings to the state object.\n   * @param {SimpleKeyring|HDKeyring} keyring\n   * @returns {Promise<Object>} A keyring display object, with type and accounts properties.\n   */\n\n\n  async _dataForKeyring(keyring) {\n    const accounts = await keyring.getAccounts();\n    return {\n      type: keyring.type,\n      accounts: accounts\n    };\n  }\n  /**\n   * Clear Keyrings\n   *\n   * Deallocates all currently managed keyrings and accounts.\n   * Used before initializing a new vault.\n   */\n\n\n  async _clearKeyrings() {\n    // clear keyrings from memory\n    this.keyrings = [];\n    this.memStore.updateState({\n      keyrings: []\n    });\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(keyringTypes, \"keyringTypes\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/keyring.js\");\n  reactHotLoader.register(KeyringController, \"KeyringController\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/keyring.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["ObservableStore","SimpleKeyring","EventEmitter","require","keyringTypes","KeyringController","constructor","opts","initState","store","concat","memStore","isUnlocked","map","krt","type","keyrings","fullUpdate","emit","getState","_updateMemStoreKeyrings","Promise","all","_dataForKeyring","updateState","addNewKeyring","Keyring","_getKeyringClassForType","keyring","getAccounts","then","push","addresses","kr","keyringArrays","reduce","res","arr","addNewAccount","selectedKeyring","addedAccounts","addAccounts","forEach","address","getKeyringsByType","filter","getPrimaryKeyring","signTransaction","fromAddress","txJson","_getKeyringForAccount","signAndSendTransaction","transaction","networkChainId","find","candidates","winners","candidate","accounts","includes","length","Error","_clearKeyrings"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/keyring.js"],"sourcesContent":["import ObservableStore from '../utils/ObservableStore';\nimport SimpleKeyring from '../keyrings/simple/index';\n\nconst { EventEmitter } = require('events');\n\nconst keyringTypes = [\n    SimpleKeyring,\n]\n\nexport default class KeyringController extends EventEmitter {\n\n    //\n    // PUBLIC METHODS\n    //\n\n    constructor (opts) {\n        super();\n\n        const initState = opts.initState || {};\n        this.store = new ObservableStore(initState);\n        this.keyringTypes = opts.keyringTypes ? keyringTypes.concat(opts.keyringTypes) : keyringTypes\n\n        this.memStore = new ObservableStore({\n            isUnlocked: false,\n            keyringTypes: this.keyringTypes.map((krt) => krt.type),\n            keyrings: [],\n        });\n\n        this.keyrings = [];\n    }\n\n    /**\n     * Full Update\n     *\n     * Emits the `update` event and @returns a Promise that resolves to\n     * the current state.\n     *\n     * Frequently used to end asynchronous chains in this class,\n     * indicating consumers can often either listen for updates,\n     * or accept a state-resolving promise to consume their results.\n     *\n     * @returns {Object} The controller state.\n     */\n    fullUpdate () {\n        this.emit('update', this.memStore.getState());\n        return this.memStore.getState();\n    }\n\n    /**\n     * Update Memstore Keyrings\n     *\n     * Updates the in-memory keyrings, without persisting.\n     */\n    async _updateMemStoreKeyrings () {\n        const keyrings = await Promise.all(this.keyrings.map(this._dataForKeyring));\n        return this.memStore.updateState({ keyrings });\n    }\n\n    /**\n     * Add New Keyring\n     *\n     * Adds a new Keyring of the given `type` to the vault\n     * and the current decrypted Keyrings array.\n     *\n     * All Keyring classes implement a unique `type` string,\n     * and this is used to retrieve them from the keyringTypes array.\n     *\n     * @param {string} type - The type of keyring to add.\n     * @param {Object} opts - The constructor options for the keyring.\n     * @returns {Promise<SimpleKeyring|HDKeyring>} The new keyring.\n     */\n    addNewKeyring (type, opts) {\n        const Keyring = this._getKeyringClassForType(type);\n        const keyring = new Keyring(opts);\n        return keyring.getAccounts()\n            .then(() => {\n                this.keyrings.push(keyring);\n            })\n            .then(() => this._updateMemStoreKeyrings())\n            .then(() => this.fullUpdate())\n            .then(() => {\n                return keyring;\n            });\n    }\n\n    /**\n     * Get Accounts\n     *\n     * Returns the public addresses of all current accounts\n     * managed by all currently unlocked keyrings.\n     *\n     * @returns {Promise<Array<string>>} The array of accounts.\n     */\n    async getAccounts () {\n        const keyrings = this.keyrings || [];\n        const addresses = await Promise.all(keyrings.map((kr) => kr.getAccounts()))\n            .then((keyringArrays) => {\n                return keyringArrays.reduce((res, arr) => {\n                    return res.concat(arr);\n                }, []);\n            });\n        return addresses;\n    }\n\n    /**\n     * Add New Account\n     *\n     * Calls the `addAccounts` method on the given keyring,\n     * and then saves those changes.\n     *\n     * @param {SimpleKeyring|HDKeyring} selectedKeyring - The currently selected keyring.\n     * @returns {Promise<Object>} A Promise that resolves to the state.\n     */\n    async addNewAccount(selectedKeyring) {\n        const addedAccounts = await selectedKeyring.addAccounts(1);\n        addedAccounts.forEach((address) => {\n            this.emit('newAccount', address);\n        });\n        await this._updateMemStoreKeyrings();\n        return await this.fullUpdate();\n    }\n\n    /**\n     * Get Keyrings by Type\n     *\n     * Gets all keyrings of the given type.\n     *\n     * @param {string} type - The keyring types to retrieve.\n     * @returns {Array<SimpleKeyring|HDKeyring>} The keyrings.\n     */\n    getKeyringsByType (type) {\n        return this.keyrings.filter((keyring) => keyring.type === type);\n    }\n\n    /**\n     * Get Keyrings by Type\n     *\n     * Gets all keyrings of the given type.\n     *\n     * @param {string} type - The keyring types to retrieve.\n     * @returns {SimpleKeyring|HDKeyring} The keyrings.\n     */\n    getPrimaryKeyring () {\n        // Only supports one account for now\n        return this.keyrings[0];\n    }\n\n    //\n    // SIGNING METHODS\n    //\n\n    /**\n     * Sign Dnero Transaction\n     *\n     * Signs a Dnero transaction object.\n     *\n     * @param {string} fromAddress - The transaction 'from' address.\n     * @param {Object} txJson - The dnero transaction (JSON format) to sign.\n     * @returns {Promise<Object>} The signed transaction bytes.\n     */\n    signTransaction (fromAddress, txJson) {\n        return this._getKeyringForAccount(fromAddress)\n            .then((keyring) => {\n                return keyring.signTransaction(fromAddress, txJson);\n            });\n    }\n\n    signAndSendTransaction(fromAddress, transaction, networkChainId) {\n        return this._getKeyringForAccount(fromAddress)\n            .then((keyring) => {\n                return keyring.signAndSendTransaction(fromAddress, transaction, networkChainId);\n            });\n    }\n\n    //\n    // PRIVATE METHODS\n    //\n\n    /**\n     * Get Keyring Class For Type\n     *\n     * Searches the current `keyringTypes` array\n     * for a Keyring class whose unique `type` property\n     * matches the provided `type`,\n     * returning it if it exists.\n     *\n     * @param {string} type - The type whose class to get.\n     * @returns {SimpleKeyring|HdKeyring} The class, if it exists.\n     */\n    _getKeyringClassForType (type) {\n        return this.keyringTypes.find((kr) => kr.type === type)\n    }\n\n    /**\n     * Get Keyring For Account\n     *\n     * Returns the currently initialized keyring that manages\n     * the specified `address` if one exists.\n     *\n     * @param {string} address - An account address.\n     * @returns {Promise<SimpleKeyring|HDKeyring>} The keyring of the account, if it exists.\n     */\n    _getKeyringForAccount (address) {\n        return Promise.all(this.keyrings.map((keyring) => {\n            return Promise.all([\n                keyring,\n                keyring.getAccounts(),\n            ]);\n        }))\n            .then((candidates) => {\n                const winners = candidates.filter((candidate) => {\n                    const accounts = candidate[1];\n                    return accounts.includes(address);\n                });\n                if (winners && winners.length > 0) {\n                    return winners[0][0];\n                }\n                throw new Error('No keyring found for the requested account.');\n            });\n    }\n\n    /**\n     * Display For Keyring\n     *\n     * Is used for adding the current keyrings to the state object.\n     * @param {SimpleKeyring|HDKeyring} keyring\n     * @returns {Promise<Object>} A keyring display object, with type and accounts properties.\n     */\n    async _dataForKeyring (keyring) {\n        const accounts = await keyring.getAccounts();\n        return {\n            type: keyring.type,\n            accounts: accounts,\n        };\n    }\n\n    /**\n     * Clear Keyrings\n     *\n     * Deallocates all currently managed keyrings and accounts.\n     * Used before initializing a new vault.\n     */\n    async _clearKeyrings () {\n        // clear keyrings from memory\n        this.keyrings = [];\n        this.memStore.updateState({\n            keyrings: [],\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}