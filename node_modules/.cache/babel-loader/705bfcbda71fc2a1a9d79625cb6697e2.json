{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { isResponseSuccessful } from '../../services/Api';\nexport function reduxFetch(baseAction, apiFn) {\n  let metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let {\n    onSuccess,\n    onError\n  } = opts;\n  return async function (dispatch, getState) {\n    dispatch({\n      type: `${baseAction}/START`,\n      metadata: metadata\n    });\n\n    try {\n      let response = await apiFn();\n\n      if (response) {\n        let responseJSON = await response.json();\n        response = {\n          status: response.status,\n          body: responseJSON\n        };\n      }\n\n      if (isResponseSuccessful(response)) {\n        dispatch({\n          type: `${baseAction}/SUCCESS`,\n          response: response,\n          metadata: metadata\n        });\n\n        if (onSuccess) {\n          onSuccess(dispatch, response);\n        }\n      } else {\n        dispatch({\n          type: `${baseAction}/FAILURE`,\n          response: null,\n          metadata: metadata\n        });\n\n        if (onError) {\n          onError(dispatch, response);\n        }\n      }\n    } catch (e) {\n      // Failed to parse\n      dispatch({\n        type: `${baseAction}/FAILURE`,\n        response: null,\n        metadata: metadata\n      });\n\n      if (onError) {\n        onError(dispatch, null);\n      }\n    } finally {\n      dispatch({\n        type: `${baseAction}/END`,\n        metadata: metadata\n      });\n    }\n  };\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(reduxFetch, \"reduxFetch\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/actions/Api.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["isResponseSuccessful","reduxFetch","baseAction","apiFn","metadata","opts","onSuccess","onError","dispatch","getState","type","response","responseJSON","json","status","body","e"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/actions/Api.js"],"sourcesContent":["import { isResponseSuccessful } from '../../services/Api'\n\nexport function reduxFetch(baseAction, apiFn, metadata = {}, opts = {}) {\n    let {onSuccess, onError} = opts;\n\n    return async function(dispatch, getState){\n        dispatch({\n            type : `${baseAction}/START`,\n            metadata: metadata\n        });\n\n        try {\n            let response = await apiFn();\n\n            if(response){\n                let responseJSON = await response.json();\n\n                response = {\n                    status: response.status,\n                    body: responseJSON\n                }\n            }\n\n            if(isResponseSuccessful(response)){\n                dispatch({\n                    type : `${baseAction}/SUCCESS`,\n                    response : response,\n                    metadata: metadata\n                });\n\n                if(onSuccess){\n                    onSuccess(dispatch, response);\n                }\n            }\n            else{\n                dispatch({\n                    type : `${baseAction}/FAILURE`,\n                    response : null,\n                    metadata: metadata\n                });\n\n                if(onError){\n                    onError(dispatch, response);\n                }\n            }\n\n\n        }\n        catch (e) {\n            // Failed to parse\n            dispatch({\n                type : `${baseAction}/FAILURE`,\n                response : null,\n                metadata: metadata\n            });\n\n            if(onError){\n                onError(dispatch, null);\n            }\n        }\n        finally {\n            dispatch({\n                type : `${baseAction}/END`,\n                metadata: metadata\n            });\n        }\n    };\n}\n"],"mappings":";;;;;;;;;AAAA,SAASA,oBAAT,QAAqC,oBAArC;AAEA,OAAO,SAASC,UAAT,CAAoBC,UAApB,EAAgCC,KAAhC,EAAiE;EAAA,IAA1BC,QAA0B,uEAAf,EAAe;EAAA,IAAXC,IAAW,uEAAJ,EAAI;EACpE,IAAI;IAACC,SAAD;IAAYC;EAAZ,IAAuBF,IAA3B;EAEA,OAAO,gBAAeG,QAAf,EAAyBC,QAAzB,EAAkC;IACrCD,QAAQ,CAAC;MACLE,IAAI,EAAI,GAAER,UAAW,QADhB;MAELE,QAAQ,EAAEA;IAFL,CAAD,CAAR;;IAKA,IAAI;MACA,IAAIO,QAAQ,GAAG,MAAMR,KAAK,EAA1B;;MAEA,IAAGQ,QAAH,EAAY;QACR,IAAIC,YAAY,GAAG,MAAMD,QAAQ,CAACE,IAAT,EAAzB;QAEAF,QAAQ,GAAG;UACPG,MAAM,EAAEH,QAAQ,CAACG,MADV;UAEPC,IAAI,EAAEH;QAFC,CAAX;MAIH;;MAED,IAAGZ,oBAAoB,CAACW,QAAD,CAAvB,EAAkC;QAC9BH,QAAQ,CAAC;UACLE,IAAI,EAAI,GAAER,UAAW,UADhB;UAELS,QAAQ,EAAGA,QAFN;UAGLP,QAAQ,EAAEA;QAHL,CAAD,CAAR;;QAMA,IAAGE,SAAH,EAAa;UACTA,SAAS,CAACE,QAAD,EAAWG,QAAX,CAAT;QACH;MACJ,CAVD,MAWI;QACAH,QAAQ,CAAC;UACLE,IAAI,EAAI,GAAER,UAAW,UADhB;UAELS,QAAQ,EAAG,IAFN;UAGLP,QAAQ,EAAEA;QAHL,CAAD,CAAR;;QAMA,IAAGG,OAAH,EAAW;UACPA,OAAO,CAACC,QAAD,EAAWG,QAAX,CAAP;QACH;MACJ;IAGJ,CApCD,CAqCA,OAAOK,CAAP,EAAU;MACN;MACAR,QAAQ,CAAC;QACLE,IAAI,EAAI,GAAER,UAAW,UADhB;QAELS,QAAQ,EAAG,IAFN;QAGLP,QAAQ,EAAEA;MAHL,CAAD,CAAR;;MAMA,IAAGG,OAAH,EAAW;QACPA,OAAO,CAACC,QAAD,EAAW,IAAX,CAAP;MACH;IACJ,CAhDD,SAiDQ;MACJA,QAAQ,CAAC;QACLE,IAAI,EAAI,GAAER,UAAW,MADhB;QAELE,QAAQ,EAAEA;MAFL,CAAD,CAAR;IAIH;EACJ,CA7DD;AA8DH;;;;;;;;;;0BAjEeH,U"},"metadata":{},"sourceType":"module"}