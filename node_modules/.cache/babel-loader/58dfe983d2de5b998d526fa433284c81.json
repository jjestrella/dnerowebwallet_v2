{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport _ from 'lodash';\nimport ObservableStore from '../utils/ObservableStore';\nimport * as dnerojs from '@dnerolabs/dnero-js';\n\nconst {\n  EventEmitter\n} = require('events');\n\nexport default class PreferencesController extends EventEmitter {\n  /**\n   *\n   * @typedef {Object} PreferencesController\n   * @param {Object} opts - Overrides the defaults for the initial state of this.store\n   * @property {Object} store The stored object containing a users preferences, stored in local storage\n   * @property {Array} store.tokens The tokens the user wants display in their token lists\n   * @property {Object} store.accountTokens The tokens stored per account and then per network type\n   * @property {Object} store.assetImages Contains assets objects related to assets added\n   * @property {string} store.selectedAddress A hex string that matches the currently selected address in the app\n   *\n   */\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    const initState = {\n      accountTokens: {},\n      assetImages: {},\n      tokens: [],\n      identities: {},\n      lostIdentities: {},\n      preferences: {\n        autoLockTimeLimit: undefined\n      },\n      completedOnboarding: false,\n      selectedAddress: null,\n      network: {\n        chainId: dnerojs.networks.ChainIds.Mainnet\n      },\n      delegatedSentryNodes: [],\n      ...opts.initState\n    };\n    this.store = new ObservableStore(initState);\n    this.updateDelegatedSentryNodes();\n  } // PUBLIC METHODS\n\n\n  getAssetImages() {\n    return this.store.getState().assetImages;\n  }\n  /**\n   * Synchronizes identity entries with known accounts.\n   * Removes any unknown identities, and returns the resulting selected address.\n   *\n   * @param {Array<string>} addresses - known to the vault.\n   * @returns {string} selectedAddress the selected address.\n   */\n\n\n  syncAddresses(addresses) {\n    if (!Array.isArray(addresses) || addresses.length === 0) {\n      throw new Error('Expected non-empty array of addresses.');\n    }\n\n    const {\n      identities,\n      lostIdentities\n    } = this.store.getState();\n    const newlyLost = {};\n    Object.keys(identities).forEach(identity => {\n      if (!addresses.includes(identity)) {\n        newlyLost[identity] = identities[identity];\n        delete identities[identity];\n      }\n    }); // Identities are no longer present.\n\n    if (Object.keys(newlyLost).length > 0) {\n      // store lost accounts\n      Object.keys(newlyLost).forEach(key => {\n        lostIdentities[key] = newlyLost[key];\n      });\n    }\n\n    this.store.updateState({\n      identities,\n      lostIdentities\n    });\n    this.addAddresses(addresses); // If the selected account is no longer valid,\n    // select an arbitrary other account:\n\n    let selectedAddr = this.getSelectedAddress();\n\n    if (!addresses.includes(selectedAddr)) {\n      selectedAddr = addresses[0];\n      this.setSelectedAddress(selectedAddr);\n    }\n\n    return selectedAddr;\n  }\n  /**\n   * Updates identities to only include specified addresses. Removes identities\n   * not included in addresses array\n   *\n   * @param {string[]} addresses - An array of hex addresses\n   *\n   */\n\n\n  setAddresses(addresses) {\n    const oldIdentities = this.store.getState().identities;\n    const oldAccountTokens = this.store.getState().accountTokens;\n    const identities = addresses.reduce((ids, address, index) => {\n      const oldId = oldIdentities[address] || {};\n      ids[address] = {\n        name: `Account ${index + 1}`,\n        address,\n        ...oldId\n      };\n      return ids;\n    }, {});\n    const accountTokens = addresses.reduce((tokens, address) => {\n      const oldTokens = oldAccountTokens[address] || {};\n      tokens[address] = oldTokens;\n      return tokens;\n    }, {});\n    this.store.updateState({\n      identities,\n      accountTokens\n    });\n  }\n  /**\n   * Removes an address from state\n   *\n   * @param {string} address - A hex address\n   * @returns {string} the address that was removed\n   */\n\n\n  removeAddress(address) {\n    const {\n      identities\n    } = this.store.getState();\n    const {\n      accountTokens\n    } = this.store.getState();\n\n    if (!identities[address]) {\n      throw new Error(`${address} can't be deleted cause it was not found`);\n    }\n\n    delete identities[address];\n    delete accountTokens[address];\n    this.store.updateState({\n      identities,\n      accountTokens\n    }); // If the selected account is no longer valid,\n    // select an arbitrary other account:\n\n    if (address === this.getSelectedAddress()) {\n      const selected = Object.keys(identities)[0];\n      this.setSelectedAddress(selected);\n    }\n\n    return address;\n  }\n  /**\n   * Adds addresses to the identities object without removing identities\n   *\n   * @param {string[]} addresses - An array of hex addresses\n   *\n   */\n\n\n  addAddresses(addresses) {\n    const {\n      identities,\n      accountTokens\n    } = this.store.getState();\n    addresses.forEach(address => {\n      // skip if already exists\n      if (identities[address]) {\n        return;\n      } // add missing identity\n\n\n      const identityCount = Object.keys(identities).length;\n\n      if (_.isNil(accountTokens[address])) {\n        accountTokens[address] = {};\n      }\n\n      identities[address] = {\n        name: `Account ${identityCount + 1}`,\n        address\n      };\n    });\n    this.store.updateState({\n      identities,\n      accountTokens\n    });\n  }\n  /**\n   * Setter for the `selectedAddress` property\n   *\n   * @param {string} _address - A new hex address for an account\n   * @returns {Promise<void>} Promise resolves with tokens\n   *\n   */\n\n\n  setSelectedAddress(_address) {\n    const address = _address;\n\n    this._updateTokens(address);\n\n    const {\n      identities,\n      tokens\n    } = this.store.getState();\n    const selectedIdentity = identities[address];\n\n    if (!selectedIdentity) {\n      throw new Error(`Identity for '${address} not found`);\n    }\n\n    selectedIdentity.lastSelected = Date.now();\n    this.store.updateState({\n      identities,\n      selectedAddress: address\n    });\n    return Promise.resolve(tokens);\n  }\n  /**\n   * Getter for the `selectedAddress` property\n   *\n   * @returns {string} The hex address for the currently selected account\n   *\n   */\n\n\n  getSelectedAddress() {\n    return this.store.getState().selectedAddress;\n  }\n  /**\n   * Contains data about tokens users add to their account.\n   * @typedef {Object} AddedToken\n   * @property {string} address - The hex address for the token contract. Will be all lower cased and hex-prefixed.\n   * @property {string} symbol - The symbol of the token, usually 3 or 4 capitalized letters\n   *  {@link https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#symbol}\n   * @property {boolean} decimals - The number of decimals the token uses.\n   *  {@link https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals}\n   */\n\n  /**\n   * A getter for `tokens` and `accountTokens` related states.\n   *\n   * @param {string} [selectedAddress] - A new hex address for an account\n   * @returns {Object.<array, object, string, string>} States to interact with tokens in `accountTokens`\n   *\n   */\n\n\n  _getTokenRelatedStates(selectedAddress) {\n    const {\n      network,\n      accountTokens\n    } = this.store.getState();\n    const chainId = network.chainId;\n\n    if (!selectedAddress) {\n      // eslint-disable-next-line no-param-reassign\n      selectedAddress = this.store.getState().selectedAddress;\n    }\n\n    if (!(selectedAddress in accountTokens)) {\n      accountTokens[selectedAddress] = {};\n    }\n\n    if (!(chainId in accountTokens[selectedAddress])) {\n      accountTokens[selectedAddress][chainId] = [];\n    }\n\n    const tokens = accountTokens[selectedAddress][chainId];\n    return {\n      tokens,\n      accountTokens,\n      network,\n      selectedAddress\n    };\n  }\n  /**\n   * Updates `tokens` of current account and network.\n   *\n   * @param {string} selectedAddress - Account address to be updated with.\n   *\n   */\n\n\n  _updateTokens(selectedAddress) {\n    const {\n      tokens\n    } = this._getTokenRelatedStates(selectedAddress);\n\n    this.store.updateState({\n      tokens\n    });\n  }\n  /**\n   * Updates `accountTokens` and `tokens` of current account and network according to it.\n   *\n   * @param {Array} tokens - Array of tokens to be updated.\n   *\n   */\n\n\n  _updateAccountTokens(tokens, assetImages) {\n    const {\n      accountTokens,\n      network,\n      selectedAddress\n    } = this._getTokenRelatedStates();\n\n    accountTokens[selectedAddress][network.chainId] = tokens;\n    this.store.updateState({\n      accountTokens,\n      tokens,\n      assetImages\n    });\n    this.emit('accountTokensUpdated');\n  }\n  /**\n   * Adds a new token to the token array, or updates the token if passed an address that already exists.\n   * Modifies the existing tokens array from the store. All objects in the tokens array array AddedToken objects.\n   * @see AddedToken {@link AddedToken}\n   *\n   * @param {string} rawAddress - Hex address of the token contract. May or may not be a checksum address.\n   * @param {string} symbol - The symbol of the token\n   * @param {number} decimals - The number of decimals the token uses.\n   * @param {string} image - The url for the token asset.\n   * @returns {Promise<array>} Promises the new array of AddedToken objects.\n   *\n   */\n\n\n  async addToken(rawAddress, symbol, decimals, image) {\n    const address = rawAddress;\n    const newEntry = {\n      address,\n      symbol,\n      decimals\n    };\n    const {\n      tokens\n    } = this.store.getState();\n    const assetImages = this.getAssetImages();\n    const previousEntry = tokens.find(token => {\n      return token.address === address;\n    });\n    const previousIndex = tokens.indexOf(previousEntry);\n\n    if (previousEntry) {\n      tokens[previousIndex] = newEntry;\n    } else {\n      tokens.push(newEntry);\n    }\n\n    assetImages[address] = image;\n\n    this._updateAccountTokens(tokens, assetImages);\n\n    return Promise.resolve(tokens);\n  }\n  /**\n   * Removes a specified token from the tokens array.\n   *\n   * @param {string} rawAddress - Hex address of the token contract to remove.\n   * @returns {Promise<array>} The new array of AddedToken objects\n   *\n   */\n\n\n  removeToken(rawAddress) {\n    const {\n      tokens\n    } = this.store.getState();\n    const assetImages = this.getAssetImages();\n    const updatedTokens = tokens.filter(token => token.address !== rawAddress);\n    delete assetImages[rawAddress];\n\n    this._updateAccountTokens(updatedTokens, assetImages);\n\n    return Promise.resolve(updatedTokens);\n  }\n  /**\n   * A getter for the `tokens` property\n   *\n   * @returns {Array} The current array of AddedToken objects\n   *\n   */\n\n\n  getTokens() {\n    return this.store.getState().tokens;\n  }\n  /**\n   * Sets a custom label for an account\n   * @param {string} account - the account to set a label for\n   * @param {string} name - the custom name for the account\n   * @returns {Promise<string>}\n   */\n\n\n  setAccountName(account, name) {\n    if (!account) {\n      throw new Error(`setAccountLabel requires a valid address, got ${String(account)}`);\n    }\n\n    const address = account;\n    const {\n      identities\n    } = this.store.getState();\n    identities[address] = identities[address] || {};\n    identities[address].name = name;\n    this.store.updateState({\n      identities\n    });\n    return Promise.resolve(name);\n  }\n  /**\n   * Updates the `preferences` property, which is an object. These are user-controlled features\n   * found in the settings page.\n   * @param {string} preference - The preference to enable or disable.\n   * @param {boolean} value - Indicates whether or not the preference should be enabled or disabled.\n   * @returns {Promise<object>} Promises a new object; the updated preferences object.\n   */\n\n\n  setPreference(preference, value) {\n    const currentPreferences = this.getPreferences();\n    const updatedPreferences = { ...currentPreferences,\n      [preference]: value\n    };\n    this.store.updateState({\n      preferences: updatedPreferences\n    });\n    return Promise.resolve(updatedPreferences);\n  }\n  /**\n   * A getter for the `preferences` property\n   * @returns {Object} A key-boolean map of user-selected preferences.\n   */\n\n\n  getPreferences() {\n    return this.store.getState().preferences;\n  }\n  /**\n   * Sets the completedOnboarding state to true, indicating that the user has completed the\n   * onboarding process.\n   */\n\n\n  completeOnboarding() {\n    this.store.updateState({\n      completedOnboarding: true\n    });\n    return Promise.resolve(true);\n  }\n  /**\n   * Updates the `network` property.\n   * @param {object} network - {chainId: String}\n   * @returns {Promise<Boolean>} Promises a new object; the updated preferences object.\n   */\n\n\n  setNetwork(network) {\n    if (network.chainId === undefined || network.chainId === null) {\n      throw new Error('PreferencesController :: setNetwork - network is invalid');\n    }\n\n    this.store.updateState({\n      network: network\n    });\n\n    this._updateTokens(this.getSelectedAddress());\n\n    this.emit('networkChanged', network);\n    return Promise.resolve(true);\n  }\n  /**\n   * A getter for the `network` property\n   * @returns {Object}\n   */\n\n\n  getNetwork() {\n    return this.store.getState().network;\n  }\n  /**\n   * Calls API to get the delegated sentry nodes\n   * @returns {Object}\n   */\n\n\n  async updateDelegatedSentryNodes() {\n    let delegatedSentryNodes = null;\n\n    try {\n      //const url = `https://api.dnerochain.org/v1/sentry/delegated-nodes`;\n      const url = `http://143.198.132.249:7554/api/v1/sentry/delegated-nodes`;\n      const response = await fetch(url);\n      const responseJson = await response.json();\n      delegatedSentryNodes = responseJson;\n      delegatedSentryNodes = _.map(delegatedSentryNodes, node => {\n        const [fee, address] = node.address.split(' fee - ');\n        return { ...node,\n          fee: fee,\n          address: address\n        };\n      });\n    } catch (e) {\n      // No Update\n      return [];\n    } // Update states\n\n\n    this.store.updateState({\n      delegatedSentryNodes\n    });\n    return delegatedSentryNodes;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(PreferencesController, \"PreferencesController\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/preferences.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["_","ObservableStore","dnerojs","EventEmitter","require","PreferencesController","constructor","opts","initState","accountTokens","assetImages","tokens","identities","lostIdentities","preferences","autoLockTimeLimit","undefined","completedOnboarding","selectedAddress","network","chainId","networks","ChainIds","Mainnet","delegatedSentryNodes","store","updateDelegatedSentryNodes","getAssetImages","getState","syncAddresses","addresses","Array","isArray","length","Error","newlyLost","Object","keys","forEach","identity","includes","key","updateState","addAddresses","selectedAddr","getSelectedAddress","setSelectedAddress","setAddresses","oldIdentities","oldAccountTokens","reduce","ids","address","index","oldId","name","oldTokens","removeAddress","selected","identityCount","isNil","_address","_updateTokens","selectedIdentity","lastSelected","Date","now","Promise","resolve","_getTokenRelatedStates","_updateAccountTokens","emit","addToken","rawAddress","symbol","decimals","image","newEntry","previousEntry","find","token","previousIndex","indexOf","push","removeToken","updatedTokens","filter","getTokens","setAccountName","account","String","setPreference","preference","value","currentPreferences","getPreferences","updatedPreferences","completeOnboarding","setNetwork","getNetwork","url","response","fetch","responseJson","json","map","node","fee","split","e"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/controllers/preferences.js"],"sourcesContent":["import _ from 'lodash';\nimport ObservableStore from '../utils/ObservableStore';\nimport * as dnerojs from '@dnerolabs/dnero-js';\n\nconst { EventEmitter } = require('events');\n\nexport default class PreferencesController  extends EventEmitter {\n    /**\n     *\n     * @typedef {Object} PreferencesController\n     * @param {Object} opts - Overrides the defaults for the initial state of this.store\n     * @property {Object} store The stored object containing a users preferences, stored in local storage\n     * @property {Array} store.tokens The tokens the user wants display in their token lists\n     * @property {Object} store.accountTokens The tokens stored per account and then per network type\n     * @property {Object} store.assetImages Contains assets objects related to assets added\n     * @property {string} store.selectedAddress A hex string that matches the currently selected address in the app\n     *\n     */\n    constructor(opts = {}) {\n        super();\n\n        const initState = {\n            accountTokens: {},\n            assetImages: {},\n            tokens: [],\n\n            identities: {},\n            lostIdentities: {},\n\n            preferences: {\n                autoLockTimeLimit: undefined,\n            },\n            completedOnboarding: false,\n\n            selectedAddress: null,\n\n            network: {\n                chainId: dnerojs.networks.ChainIds.Mainnet,\n            },\n\n            delegatedSentryNodes: [],\n\n            ...opts.initState,\n        };\n\n        this.store = new ObservableStore(initState);\n\n        this.updateDelegatedSentryNodes();\n    }\n\n\n    // PUBLIC METHODS\n\n    getAssetImages() {\n        return this.store.getState().assetImages;\n    }\n\n    /**\n     * Synchronizes identity entries with known accounts.\n     * Removes any unknown identities, and returns the resulting selected address.\n     *\n     * @param {Array<string>} addresses - known to the vault.\n     * @returns {string} selectedAddress the selected address.\n     */\n    syncAddresses(addresses) {\n        if (!Array.isArray(addresses) || addresses.length === 0) {\n            throw new Error('Expected non-empty array of addresses.');\n        }\n\n        const { identities, lostIdentities } = this.store.getState();\n\n        const newlyLost = {};\n        Object.keys(identities).forEach((identity) => {\n            if (!addresses.includes(identity)) {\n                newlyLost[identity] = identities[identity];\n                delete identities[identity];\n            }\n        });\n\n        // Identities are no longer present.\n        if (Object.keys(newlyLost).length > 0) {\n            // store lost accounts\n            Object.keys(newlyLost).forEach((key) => {\n                lostIdentities[key] = newlyLost[key];\n            });\n        }\n\n        this.store.updateState({ identities, lostIdentities });\n        this.addAddresses(addresses);\n\n        // If the selected account is no longer valid,\n        // select an arbitrary other account:\n        let selectedAddr = this.getSelectedAddress();\n        if (!addresses.includes(selectedAddr)) {\n            selectedAddr = addresses[0];\n            this.setSelectedAddress(selectedAddr);\n        }\n\n        return selectedAddr;\n    }\n\n    /**\n     * Updates identities to only include specified addresses. Removes identities\n     * not included in addresses array\n     *\n     * @param {string[]} addresses - An array of hex addresses\n     *\n     */\n    setAddresses(addresses) {\n        const oldIdentities = this.store.getState().identities;\n        const oldAccountTokens = this.store.getState().accountTokens;\n\n        const identities = addresses.reduce((ids, address, index) => {\n            const oldId = oldIdentities[address] || {};\n            ids[address] = { name: `Account ${index + 1}`, address, ...oldId };\n            return ids;\n        }, {});\n        const accountTokens = addresses.reduce((tokens, address) => {\n            const oldTokens = oldAccountTokens[address] || {};\n            tokens[address] = oldTokens;\n            return tokens;\n        }, {});\n        this.store.updateState({ identities, accountTokens });\n    }\n\n    /**\n     * Removes an address from state\n     *\n     * @param {string} address - A hex address\n     * @returns {string} the address that was removed\n     */\n    removeAddress(address) {\n        const { identities } = this.store.getState();\n        const { accountTokens } = this.store.getState();\n        if (!identities[address]) {\n            throw new Error(`${address} can't be deleted cause it was not found`);\n        }\n        delete identities[address];\n        delete accountTokens[address];\n        this.store.updateState({ identities, accountTokens });\n\n        // If the selected account is no longer valid,\n        // select an arbitrary other account:\n        if (address === this.getSelectedAddress()) {\n            const selected = Object.keys(identities)[0];\n            this.setSelectedAddress(selected);\n        }\n        return address;\n    }\n\n    /**\n     * Adds addresses to the identities object without removing identities\n     *\n     * @param {string[]} addresses - An array of hex addresses\n     *\n     */\n    addAddresses(addresses) {\n        const { identities, accountTokens } = this.store.getState();\n        addresses.forEach((address) => {\n            // skip if already exists\n            if (identities[address]) {\n                return;\n            }\n            // add missing identity\n            const identityCount = Object.keys(identities).length;\n\n            if(_.isNil(accountTokens[address])){\n                accountTokens[address] = {};\n            }\n\n            identities[address] = { name: `Account ${identityCount + 1}`, address };\n        });\n        this.store.updateState({ identities, accountTokens });\n    }\n\n    /**\n     * Setter for the `selectedAddress` property\n     *\n     * @param {string} _address - A new hex address for an account\n     * @returns {Promise<void>} Promise resolves with tokens\n     *\n     */\n    setSelectedAddress(_address) {\n        const address = _address;\n        this._updateTokens(address);\n\n        const { identities, tokens } = this.store.getState();\n        const selectedIdentity = identities[address];\n        if (!selectedIdentity) {\n            throw new Error(`Identity for '${address} not found`);\n        }\n\n        selectedIdentity.lastSelected = Date.now();\n        this.store.updateState({ identities, selectedAddress: address });\n        return Promise.resolve(tokens);\n    }\n\n    /**\n     * Getter for the `selectedAddress` property\n     *\n     * @returns {string} The hex address for the currently selected account\n     *\n     */\n    getSelectedAddress() {\n        return this.store.getState().selectedAddress;\n    }\n\n    /**\n     * Contains data about tokens users add to their account.\n     * @typedef {Object} AddedToken\n     * @property {string} address - The hex address for the token contract. Will be all lower cased and hex-prefixed.\n     * @property {string} symbol - The symbol of the token, usually 3 or 4 capitalized letters\n     *  {@link https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#symbol}\n     * @property {boolean} decimals - The number of decimals the token uses.\n     *  {@link https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals}\n     */\n\n    /**\n     * A getter for `tokens` and `accountTokens` related states.\n     *\n     * @param {string} [selectedAddress] - A new hex address for an account\n     * @returns {Object.<array, object, string, string>} States to interact with tokens in `accountTokens`\n     *\n     */\n    _getTokenRelatedStates(selectedAddress) {\n        const { network, accountTokens } = this.store.getState();\n        const chainId = network.chainId;\n\n        if (!selectedAddress) {\n            // eslint-disable-next-line no-param-reassign\n            selectedAddress = this.store.getState().selectedAddress;\n        }\n        if (!(selectedAddress in accountTokens)) {\n            accountTokens[selectedAddress] = {};\n        }\n        if (!(chainId in accountTokens[selectedAddress])) {\n            accountTokens[selectedAddress][chainId] = [];\n        }\n        const tokens = accountTokens[selectedAddress][chainId];\n        return { tokens, accountTokens, network, selectedAddress };\n    }\n\n    /**\n     * Updates `tokens` of current account and network.\n     *\n     * @param {string} selectedAddress - Account address to be updated with.\n     *\n     */\n    _updateTokens(selectedAddress) {\n        const { tokens } = this._getTokenRelatedStates(selectedAddress);\n        this.store.updateState({ tokens });\n    }\n\n    /**\n     * Updates `accountTokens` and `tokens` of current account and network according to it.\n     *\n     * @param {Array} tokens - Array of tokens to be updated.\n     *\n     */\n    _updateAccountTokens(tokens, assetImages) {\n        const {\n            accountTokens,\n            network,\n            selectedAddress,\n        } = this._getTokenRelatedStates();\n        accountTokens[selectedAddress][network.chainId] = tokens;\n        this.store.updateState({ accountTokens, tokens, assetImages });\n\n        this.emit('accountTokensUpdated');\n    }\n\n    /**\n     * Adds a new token to the token array, or updates the token if passed an address that already exists.\n     * Modifies the existing tokens array from the store. All objects in the tokens array array AddedToken objects.\n     * @see AddedToken {@link AddedToken}\n     *\n     * @param {string} rawAddress - Hex address of the token contract. May or may not be a checksum address.\n     * @param {string} symbol - The symbol of the token\n     * @param {number} decimals - The number of decimals the token uses.\n     * @param {string} image - The url for the token asset.\n     * @returns {Promise<array>} Promises the new array of AddedToken objects.\n     *\n     */\n    async addToken(rawAddress, symbol, decimals, image) {\n        const address = rawAddress;\n        const newEntry = { address, symbol, decimals };\n        const { tokens } = this.store.getState();\n        const assetImages = this.getAssetImages();\n        const previousEntry = tokens.find((token) => {\n            return token.address === address;\n        });\n        const previousIndex = tokens.indexOf(previousEntry);\n\n        if (previousEntry) {\n            tokens[previousIndex] = newEntry;\n        } else {\n            tokens.push(newEntry);\n        }\n        assetImages[address] = image;\n        this._updateAccountTokens(tokens, assetImages);\n        return Promise.resolve(tokens);\n    }\n\n    /**\n     * Removes a specified token from the tokens array.\n     *\n     * @param {string} rawAddress - Hex address of the token contract to remove.\n     * @returns {Promise<array>} The new array of AddedToken objects\n     *\n     */\n    removeToken(rawAddress) {\n        const { tokens } = this.store.getState();\n        const assetImages = this.getAssetImages();\n        const updatedTokens = tokens.filter((token) => token.address !== rawAddress);\n        delete assetImages[rawAddress];\n        this._updateAccountTokens(updatedTokens, assetImages);\n        return Promise.resolve(updatedTokens);\n    }\n\n    /**\n     * A getter for the `tokens` property\n     *\n     * @returns {Array} The current array of AddedToken objects\n     *\n     */\n    getTokens() {\n        return this.store.getState().tokens;\n    }\n\n    /**\n     * Sets a custom label for an account\n     * @param {string} account - the account to set a label for\n     * @param {string} name - the custom name for the account\n     * @returns {Promise<string>}\n     */\n    setAccountName(account, name) {\n        if (!account) {\n            throw new Error(\n                `setAccountLabel requires a valid address, got ${String(account)}`,\n            );\n        }\n        const address = account;\n        const { identities } = this.store.getState();\n        identities[address] = identities[address] || {};\n        identities[address].name = name;\n        this.store.updateState({ identities });\n        return Promise.resolve(name);\n    }\n\n    /**\n     * Updates the `preferences` property, which is an object. These are user-controlled features\n     * found in the settings page.\n     * @param {string} preference - The preference to enable or disable.\n     * @param {boolean} value - Indicates whether or not the preference should be enabled or disabled.\n     * @returns {Promise<object>} Promises a new object; the updated preferences object.\n     */\n    setPreference(preference, value) {\n        const currentPreferences = this.getPreferences();\n        const updatedPreferences = {\n            ...currentPreferences,\n            [preference]: value,\n        };\n\n        this.store.updateState({ preferences: updatedPreferences });\n        return Promise.resolve(updatedPreferences);\n    }\n\n    /**\n     * A getter for the `preferences` property\n     * @returns {Object} A key-boolean map of user-selected preferences.\n     */\n    getPreferences() {\n        return this.store.getState().preferences;\n    }\n\n    /**\n     * Sets the completedOnboarding state to true, indicating that the user has completed the\n     * onboarding process.\n     */\n    completeOnboarding() {\n        this.store.updateState({ completedOnboarding: true });\n        return Promise.resolve(true);\n    }\n\n    /**\n     * Updates the `network` property.\n     * @param {object} network - {chainId: String}\n     * @returns {Promise<Boolean>} Promises a new object; the updated preferences object.\n     */\n    setNetwork(network) {\n        if(network.chainId === undefined || network.chainId === null){\n            throw new Error('PreferencesController :: setNetwork - network is invalid');\n        }\n\n        this.store.updateState({ network: network });\n\n        this._updateTokens(this.getSelectedAddress());\n\n        this.emit('networkChanged', network);\n\n        return Promise.resolve(true);\n    }\n\n    /**\n     * A getter for the `network` property\n     * @returns {Object}\n     */\n    getNetwork() {\n        return this.store.getState().network;\n    }\n\n    /**\n     * Calls API to get the delegated sentry nodes\n     * @returns {Object}\n     */\n    async updateDelegatedSentryNodes(){\n        let delegatedSentryNodes = null;\n\n        try {\n            //const url = `https://api.dnerochain.org/v1/sentry/delegated-nodes`;\n            const url = `http://143.198.132.249:7554/api/v1/sentry/delegated-nodes`;\n            const response = await fetch(url);\n            const responseJson = await response.json();\n            delegatedSentryNodes = responseJson;\n            delegatedSentryNodes = _.map(delegatedSentryNodes, (node) => {\n                const [fee, address] = node.address.split(' fee - ');\n\n                return {\n                    ...node,\n                    fee: fee,\n                    address: address\n                };\n            });\n        }\n        catch (e) {\n            // No Update\n            return [];\n        }\n\n        // Update states\n        this.store.updateState({ delegatedSentryNodes });\n\n        return delegatedSentryNodes;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}