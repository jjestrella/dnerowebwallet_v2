{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport BigNumber from 'bignumber.js';\nimport Bytes from 'eth-lib/lib/bytes';\nimport RLP from 'eth-lib/lib/rlp';\nimport Hash from 'eth-lib/lib/hash';\n\nclass Tx {\n  constructor() {}\n\n  signBytes(chainID) {}\n\n  getType() {}\n\n  rlpInput() {}\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n} // /**\n//  * Check if string is HEX, requires a 0x in front\n//  *\n//  * @method isHexStrict\n//  *\n//  * @param {String} hex to be checked\n//  *\n//  * @returns {Boolean}\n//  */\n\n\nconst isHexStrict = hex => {\n  return (isString(hex) || isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n *\n * @param {String} hex\n *\n * @returns {Array} the byte array\n */\n\n\nconst hexToBytes = hex => {\n  hex = hex.toString(16);\n\n  if (!isHexStrict(hex)) {\n    throw new Error(`Given value \"${hex}\" is not a valid hex string.`);\n  }\n\n  hex = hex.replace(/^0x/i, '');\n  hex = hex.length % 2 ? '0' + hex : hex;\n  let bytes = [];\n\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substr(c, 2), 16));\n  }\n\n  return bytes;\n}; // Convert a byte array to a hex string\n\n\nconst bytesToHex = function (bytes) {\n  for (var hex = [], i = 0; i < bytes.length; i++) {\n    hex.push((bytes[i] >>> 4).toString(16));\n    hex.push((bytes[i] & 0xF).toString(16));\n  }\n\n  return hex.join(\"\");\n};\n\nBigNumber.prototype.pad = function (size) {\n  var s = String(this);\n\n  while (s.length < (size || 2)) {\n    s = \"0\" + s;\n  }\n\n  return s;\n};\n\nconst bnFromString = str => {\n  const base = str.slice(0, 2) === \"0x\" ? 16 : 10;\n  const bigNum = new BigNumber(str, base);\n  const bigNumWithPad = \"0x\" + bigNum.pad(2);\n  return bigNumWithPad; // Jieyi: return \"0x00\" instead of \"0x\" to be compatible with the Golang/Java signature\n};\n\nconst encodeWei = wei => {\n  if (wei === null || wei === undefined) {\n    return Bytes.fromNat(\"0x0\");\n  } else if (wei.isEqualTo(new BigNumber(0))) {\n    return Bytes.fromNat(\"0x0\");\n  } else {\n    return Bytes.fromNumber(wei);\n  }\n};\n\nclass Coins {\n  constructor(dneroWei, dtokenWei) {\n    this.dneroWei = dneroWei;\n    this.dtokenWei = dtokenWei;\n  } // encodeWei(wei){\n  //     if(wei === null || wei === undefined){\n  //         return Bytes.fromNat(\"0x0\");\n  //     }\n  //     else if(wei.isEqualTo(new BigNumber(0))){\n  //         return Bytes.fromNat(\"0x0\");\n  //     }\n  //     else{\n  //         return Bytes.fromNumber(wei);\n  //     }\n  // }\n\n\n  rlpInput() {\n    let rlpInput = [encodeWei(this.dneroWei), encodeWei(this.dtokenWei) //(this.dneroWei.isEqualTo(new BigNumber(0))) ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.dneroWei),\n    //(this.dtokenWei.isEqualTo(new BigNumber(0))) ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.dtokenWei)\n    ];\n    return rlpInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nclass TxInput {\n  constructor(address, dneroWei, dtokenWei, sequence) {\n    this.address = address;\n    this.sequence = sequence;\n    this.signature = \"\";\n\n    if (dneroWei || dtokenWei) {\n      this.coins = new Coins(dneroWei, dtokenWei);\n    } else {\n      //TODO should this be undefined or null?\n      this.coins = new Coins(null, null);\n    }\n  }\n\n  setSignature(signature) {\n    this.signature = signature;\n  }\n\n  rlpInput() {\n    let address = null;\n\n    if (this.address) {\n      address = this.address.toLowerCase();\n    } else {\n      address = Bytes.fromNat(\"0x0\");\n    }\n\n    let rplInput = [address, this.coins.rlpInput(), Bytes.fromNumber(this.sequence), this.signature];\n    return rplInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nclass TxOutput {\n  constructor(address, dneroWei, dtokenWei) {\n    this.address = address;\n\n    if (dneroWei || dtokenWei) {\n      this.coins = new Coins(dneroWei, dtokenWei);\n    } else {\n      //TODO should this be undefined or null?\n      this.coins = new Coins(null, null);\n    }\n  }\n\n  rlpInput() {\n    let address = null;\n\n    if (this.address) {\n      address = this.address.toLowerCase();\n    } else {\n      //Empty address\n      address = \"0x0000000000000000000000000000000000000000\";\n    }\n\n    let rplInput = [address, this.coins.rlpInput()];\n    return rplInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nconst TxType = {\n  TxTypeCoinbase: 0,\n  TxTypeSlash: 1,\n  TxTypeSend: 2,\n  TxTypeReserveFund: 3,\n  TxTypeReleaseFund: 4,\n  TxTypeServicePayment: 5,\n  TxTypeSplitRule: 6,\n  TxTypeSmartContract: 7,\n  TxTypeDepositStake: 8,\n  TxTypeWithdrawStake: 9,\n  TxTypeDepositStakeV2: 10\n};\n\nclass EthereumTx {\n  constructor(payload) {\n    this.nonce = \"0x0\";\n    this.gasPrice = \"0x0\";\n    this.gas = \"0x0\";\n    this.to = \"0x0000000000000000000000000000000000000000\";\n    this.value = \"0x0\";\n    this.input = payload;\n  }\n\n  rlpInput() {\n    let rplInput = [Bytes.fromNat(this.nonce), Bytes.fromNat(this.gasPrice), Bytes.fromNat(this.gas), this.to.toLowerCase(), Bytes.fromNat(this.value), this.input];\n    return rplInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nclass SendTx extends Tx {\n  constructor(senderAddr, outputs, feeInDTokenWei, senderSequence) {\n    super();\n    let totalDneroWeiBN = new BigNumber(0);\n    let totalDtokenWeiBN = new BigNumber(0);\n    let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : new BigNumber(feeInDTokenWei);\n\n    for (var i = 0; i < outputs.length; i++) {\n      let output = outputs[i];\n      let dneroWei = output.dneroWei;\n      let dtokenWei = output.dtokenWei;\n      let dneroWeiBN = BigNumber.isBigNumber(dneroWei) ? dneroWei : new BigNumber(dneroWei);\n      let dtokenWeiBN = BigNumber.isBigNumber(dtokenWei) ? dtokenWei : new BigNumber(dtokenWei);\n      totalDneroWeiBN = totalDneroWeiBN.plus(dneroWeiBN);\n      totalDtokenWeiBN = totalDtokenWeiBN.plus(dtokenWeiBN);\n    }\n\n    this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n    let txInput = new TxInput(senderAddr, totalDneroWeiBN, totalDtokenWeiBN.plus(feeInDTokenWeiBN), senderSequence);\n    this.inputs = [txInput];\n    this.outputs = [];\n\n    for (var j = 0; j < outputs.length; j++) {\n      let output = outputs[j];\n      let address = output.address;\n      let dneroWei = output.dneroWei;\n      let dtokenWei = output.dtokenWei;\n      let dneroWeiBN = BigNumber.isBigNumber(dneroWei) ? dneroWei : new BigNumber(dneroWei);\n      let dtokenWeiBN = BigNumber.isBigNumber(dtokenWei) ? dtokenWei : new BigNumber(dtokenWei);\n      let txOutput = new TxOutput(address, dneroWeiBN, dtokenWeiBN);\n      this.outputs.push(txOutput);\n    }\n  }\n\n  setSignature(signature) {\n    //TODO support multiple inputs\n    let input = this.inputs[0];\n    input.setSignature(signature);\n  }\n\n  signBytes(chainID) {\n    let sigz = []; //let input = this.inputs[0];\n    // Detach the existing signatures from the input if any, so that we don't sign the signature\n    //let originalSignature = input.signature;\n    //input.signature = \"\";\n    // Detach the existing signatures from the input if any, so that we don't sign the signature\n\n    for (var i = 0; i < this.inputs.length; i++) {\n      let input = this.inputs[i];\n      sigz[i] = input.signature;\n      input.signature = \"\";\n    }\n\n    let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n    let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n    let encodedTx = RLP.encode(this.rlpInput());\n    let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2); // For ethereum tx compatibility, encode the tx as the payload\n\n    let ethTxWrapper = new EthereumTx(payload);\n    let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n\n    console.log(\"SendTx :: signBytes :: txRawBytes = \" + signedBytes); // Attach the original signature back to the inputs\n    //input.signature = originalSignature;\n    // Attach the original signature back to the inputs\n\n    for (var j = 0; j < this.inputs.length; j++) {\n      let input = this.inputs[j];\n      input.signature = sigz[j];\n    }\n\n    return signedBytes;\n  }\n\n  getType() {\n    return TxType.TxTypeSend;\n  }\n\n  rlpInput() {\n    let numInputs = this.inputs.length;\n    let numOutputs = this.outputs.length;\n    let inputBytesArray = [];\n    let outputBytesArray = [];\n\n    for (let i = 0; i < numInputs; i++) {\n      inputBytesArray[i] = this.inputs[i].rlpInput();\n    }\n\n    for (let i = 0; i < numOutputs; i++) {\n      outputBytesArray[i] = this.outputs[i].rlpInput();\n    }\n\n    let rlpInput = [this.fee.rlpInput(), inputBytesArray, outputBytesArray];\n    return rlpInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nconst StakePurposes = {\n  StakeForValidator: 0,\n  StakeForSentry: 1,\n  StakeForEliteEdge: 2\n};\n\nclass StakeTx extends Tx {}\n\nclass DepositStakeTx extends StakeTx {\n  constructor(source, holderAddress, stakeInDneroWei, feeInDTokenWei, purpose, senderSequence) {\n    super();\n    let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : new BigNumber(feeInDTokenWei);\n    this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n    let stakeInDneroWeiBN = BigNumber.isBigNumber(stakeInDneroWei) ? stakeInDneroWei : new BigNumber(stakeInDneroWei);\n    this.source = new TxInput(source, stakeInDneroWeiBN, null, senderSequence);\n    this.purpose = purpose; //Parse out the info from the holder (summary) param\n\n    if (!holderAddress.startsWith('0x')) {\n      holderAddress = \"0x\" + holderAddress;\n    } //Ensure correct size\n\n\n    if (holderAddress.length !== 42) {\n      //TODO: throw error\n      console.log(\"Holder must be a valid address\");\n    }\n\n    this.holder = new TxOutput(holderAddress, null, null);\n  }\n\n  setSignature(signature) {\n    let input = this.source;\n    input.setSignature(signature);\n  }\n\n  signBytes(chainID) {\n    // Detach the existing signature from the source if any, so that we don't sign the signature\n    let sig = this.source.signature;\n    this.source.signature = \"\";\n    let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n    let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n    let encodedTx = RLP.encode(this.rlpInput());\n    let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2); // For ethereum tx compatibility, encode the tx as the payload\n\n    let ethTxWrapper = new EthereumTx(payload);\n    let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n    // Attach the original signature back to the source\n\n    this.source.signature = sig;\n    return signedBytes;\n  }\n\n  getType() {\n    return TxType.TxTypeDepositStake;\n  }\n\n  rlpInput() {\n    let rlpInput = [this.fee.rlpInput(), this.source.rlpInput(), this.holder.rlpInput(), this.purpose === 0 ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.purpose)];\n    return rlpInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nclass DepositStakeV2Tx extends StakeTx {\n  static isValidHolderSummary(purpose, holderSummary) {\n    if (holderSummary) {\n      let summary = holderSummary;\n\n      if (!holderSummary.startsWith('0x')) {\n        summary = \"0x\" + holderSummary;\n      }\n\n      let expectedLen = 460; // Sentry Nodes\n\n      if (purpose === StakePurposes.StakeForEliteEdge) {\n        expectedLen = 524;\n      }\n\n      return summary.length === expectedLen;\n    } else {\n      return false;\n    }\n  }\n\n  constructor(source, holderSummary, amount, feeInDTokenWei, purpose, senderSequence) {\n    super();\n    let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : new BigNumber(feeInDTokenWei);\n    this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n    let stakeInWeiBN = BigNumber.isBigNumber(amount) ? amount : new BigNumber(amount);\n\n    if (purpose === StakePurposes.StakeForEliteEdge) {\n      // DTOKEN staking\n      this.source = new TxInput(source, null, stakeInWeiBN, senderSequence);\n    } else {\n      // DNERO staking\n      this.source = new TxInput(source, stakeInWeiBN, null, senderSequence);\n    }\n\n    this.purpose = purpose; //Parse out the info from the holder (summary) param\n\n    if (!holderSummary.startsWith('0x')) {\n      holderSummary = \"0x\" + holderSummary;\n    } //Ensure correct size\n\n\n    if (!DepositStakeV2Tx.isValidHolderSummary(purpose, holderSummary)) {\n      //TODO: throw error\n      console.log(\"Holder must be a valid node summary\");\n    } //let sentryKeyBytes = Bytes.fromString(holderSummary);\n\n\n    let nodeKeyBytes = Bytes.toArray(holderSummary); //slice instead of subarray\n\n    let holderAddressBytes = nodeKeyBytes.slice(0, 20);\n    this.blsPubkeyBytes = nodeKeyBytes.slice(20, 68);\n    this.blsPopBytes = nodeKeyBytes.slice(68, 164);\n    this.holderSigBytes = nodeKeyBytes.slice(164, 229);\n    let holderAddress = Bytes.fromArray(holderAddressBytes);\n    this.holder = new TxOutput(holderAddress, null, null);\n  }\n\n  setSignature(signature) {\n    let input = this.source;\n    input.setSignature(signature);\n  }\n\n  signBytes(chainID) {\n    // Detach the existing signature from the source if any, so that we don't sign the signature\n    let sig = this.source.signature;\n    this.source.signature = \"\";\n    let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n    let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n    let encodedTx = RLP.encode(this.rlpInput());\n    let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2); // For ethereum tx compatibility, encode the tx as the payload\n\n    let ethTxWrapper = new EthereumTx(payload);\n    let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n    // Attach the original signature back to the source\n\n    this.source.signature = sig;\n    return signedBytes;\n  }\n\n  getType() {\n    return TxType.TxTypeDepositStakeV2;\n  }\n\n  rlpInput() {\n    let rlpInput = [this.fee.rlpInput(), this.source.rlpInput(), this.holder.rlpInput(), Bytes.fromNumber(this.purpose), Bytes.fromArray(this.blsPubkeyBytes), Bytes.fromArray(this.blsPopBytes), Bytes.fromArray(this.holderSigBytes)];\n    return rlpInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nclass WithdrawStakeTx extends StakeTx {\n  constructor(source, holder, feeInDTokenWei, purpose, senderSequence) {\n    super();\n    let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : new BigNumber(feeInDTokenWei);\n    this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n    this.source = new TxInput(source, null, null, senderSequence);\n    this.holder = new TxOutput(holder, null, null);\n    this.purpose = purpose;\n  }\n\n  setSignature(signature) {\n    let input = this.source;\n    input.setSignature(signature);\n  }\n\n  signBytes(chainID) {\n    // Detach the existing signature from the source if any, so that we don't sign the signature\n    let sig = this.source.signature;\n    this.source.signature = \"\";\n    let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n    let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n    let encodedTx = RLP.encode(this.rlpInput());\n    let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2); // For ethereum tx compatibility, encode the tx as the payload\n\n    let ethTxWrapper = new EthereumTx(payload);\n    let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n\n    console.log(\"SendTx :: signBytes :: txRawBytes = \" + signedBytes); // Attach the original signature back to the source\n\n    this.source.signature = sig;\n    return signedBytes;\n  }\n\n  getType() {\n    return TxType.TxTypeWithdrawStake;\n  }\n\n  rlpInput() {\n    let rlpInput = [this.fee.rlpInput(), this.source.rlpInput(), this.holder.rlpInput(), this.purpose === 0 ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.purpose)];\n    return rlpInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nconst elliptic = window.elliptic || require(\"elliptic\");\n\nconst secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\n\nconst SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n\nconst sha3 = value => {\n  if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n    value = hexToBytes(value);\n  }\n\n  const returnValue = Hash.keccak256(value); // jshint ignore:line\n\n  if (returnValue === SHA3_NULL_S) {\n    return null;\n  } else {\n    return returnValue;\n  }\n};\n\nconst encodeSignature = _ref => {\n  let [v, r, s] = _ref;\n  return Bytes.flatten([r, s, v]);\n};\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const ecKey = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\"));\n  const signature = ecKey.sign(new Buffer(hash.slice(2), \"hex\"), {\n    canonical: true\n  });\n  return encodeSignature([bnFromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n};\n\nconst sign = makeSigner(0);\n\nclass TxSigner {\n  static signAndSerializeTx(chainID, tx, privateKey) {\n    let signedTx = this.signTx(chainID, tx, privateKey);\n    let signedRawBytes = this.serializeTx(signedTx);\n    return signedRawBytes;\n  }\n\n  static signTx(chainID, tx, privateKey) {\n    let txRawBytes = tx.signBytes(chainID);\n    let txHash = sha3(txRawBytes);\n    let signature = sign(txHash, privateKey);\n    tx.setSignature(signature);\n    return tx;\n  }\n\n  static serializeTx(tx) {\n    let encodedTxType = RLP.encode(Bytes.fromNumber(tx.getType()));\n    let encodedTx = RLP.encode(tx.rlpInput()); // this time encode with signature\n\n    let signedRawBytes = encodedTxType + encodedTx.slice(2);\n    return signedRawBytes;\n  }\n\n}\n\nvar Web3Utils = require('web3-utils');\n\nclass SmartContractTx extends Tx {\n  constructor(fromAddress, toAddress, gasLimit, gasPrice, data, value, senderSequence) {\n    super();\n    let valueWeiBN = BigNumber.isBigNumber(value) ? value : new BigNumber(value);\n    this.from = new TxInput(fromAddress, null, valueWeiBN, senderSequence);\n    this.to = new TxOutput(toAddress, null, null);\n    this.gasLimit = gasLimit;\n    this.gasPrice = gasPrice;\n\n    if (data.toLowerCase().startsWith(\"0x\") === false) {\n      data = \"0x\" + data;\n    }\n\n    this.data = Bytes.toArray(data);\n  }\n\n  setSignature(signature) {\n    let input = this.from;\n    input.setSignature(signature);\n  }\n\n  signBytes(chainID) {\n    // Detach the existing signature from the source if any, so that we don't sign the signature\n    let sig = this.from.signature;\n    this.from.signature = \"\";\n    let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n    let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n    let encodedTx = RLP.encode(this.rlpInput());\n    let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2); // For ethereum tx compatibility, encode the tx as the payload\n\n    let ethTxWrapper = new EthereumTx(payload);\n    let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n    // Attach the original signature back to the source\n\n    this.from.signature = sig;\n    return signedBytes;\n  }\n\n  getType() {\n    return TxType.TxTypeSmartContract;\n  }\n\n  rlpInput() {\n    let rlpInput = [this.from.rlpInput(), this.to.rlpInput(), Bytes.fromNumber(this.gasLimit), encodeWei(this.gasPrice), Bytes.fromArray(this.data)];\n    return rlpInput;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nvar index = {\n  SendTx,\n  DepositStakeTx: DepositStakeTx,\n  DepositStakeV2Tx: DepositStakeV2Tx,\n  WithdrawStakeTx,\n  SmartContractTx,\n  TxSigner,\n  StakePurposes,\n  Utils: {\n    hexToBytes,\n    bytesToHex\n  }\n};\nconst _default = index;\nexport default _default;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(Tx, \"Tx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(isHexStrict, \"isHexStrict\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(hexToBytes, \"hexToBytes\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(bytesToHex, \"bytesToHex\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(bnFromString, \"bnFromString\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(encodeWei, \"encodeWei\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(Coins, \"Coins\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(TxInput, \"TxInput\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(TxOutput, \"TxOutput\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(TxType, \"TxType\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(EthereumTx, \"EthereumTx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(SendTx, \"SendTx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(StakePurposes, \"StakePurposes\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(StakeTx, \"StakeTx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(DepositStakeTx, \"DepositStakeTx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(DepositStakeV2Tx, \"DepositStakeV2Tx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(WithdrawStakeTx, \"WithdrawStakeTx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(elliptic, \"elliptic\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(secp256k1, \"secp256k1\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(SHA3_NULL_S, \"SHA3_NULL_S\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(sha3, \"sha3\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(encodeSignature, \"encodeSignature\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(makeSigner, \"makeSigner\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(sign, \"sign\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(TxSigner, \"TxSigner\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(SmartContractTx, \"SmartContractTx\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(index, \"index\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n  reactHotLoader.register(_default, \"default\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["isString","isNumber","BigNumber","Bytes","RLP","Hash","Tx","constructor","signBytes","chainID","getType","rlpInput","isHexStrict","hex","test","hexToBytes","toString","Error","replace","length","bytes","c","push","parseInt","substr","bytesToHex","i","join","prototype","pad","size","s","String","bnFromString","str","base","slice","bigNum","bigNumWithPad","encodeWei","wei","undefined","fromNat","isEqualTo","fromNumber","Coins","dneroWei","dtokenWei","TxInput","address","sequence","signature","coins","setSignature","toLowerCase","rplInput","TxOutput","TxType","TxTypeCoinbase","TxTypeSlash","TxTypeSend","TxTypeReserveFund","TxTypeReleaseFund","TxTypeServicePayment","TxTypeSplitRule","TxTypeSmartContract","TxTypeDepositStake","TxTypeWithdrawStake","TxTypeDepositStakeV2","EthereumTx","payload","nonce","gasPrice","gas","to","value","input","SendTx","senderAddr","outputs","feeInDTokenWei","senderSequence","totalDneroWeiBN","totalDtokenWeiBN","feeInDTokenWeiBN","isBigNumber","output","dneroWeiBN","dtokenWeiBN","plus","fee","txInput","inputs","j","txOutput","sigz","encodedChainID","encode","fromString","encodedTxType","encodedTx","ethTxWrapper","signedBytes","console","log","numInputs","numOutputs","inputBytesArray","outputBytesArray","StakePurposes","StakeForValidator","StakeForSentry","StakeForEliteEdge","StakeTx","DepositStakeTx","source","holderAddress","stakeInDneroWei","purpose","stakeInDneroWeiBN","startsWith","holder","sig","DepositStakeV2Tx","isValidHolderSummary","holderSummary","summary","expectedLen","amount","stakeInWeiBN","nodeKeyBytes","toArray","holderAddressBytes","blsPubkeyBytes","blsPopBytes","holderSigBytes","fromArray","WithdrawStakeTx","elliptic","window","require","secp256k1","ec","SHA3_NULL_S","sha3","returnValue","keccak256","encodeSignature","v","r","flatten","makeSigner","addToV","hash","privateKey","ecKey","keyFromPrivate","Buffer","sign","canonical","recoveryParam","TxSigner","signAndSerializeTx","tx","signedTx","signTx","signedRawBytes","serializeTx","txRawBytes","txHash","Web3Utils","SmartContractTx","fromAddress","toAddress","gasLimit","data","valueWeiBN","from","index","Utils"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/libs/dnerojs.esm.js"],"sourcesContent":["import isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport BigNumber from 'bignumber.js';\nimport Bytes from 'eth-lib/lib/bytes';\nimport RLP from 'eth-lib/lib/rlp';\nimport Hash from 'eth-lib/lib/hash';\n\nclass Tx{\n    constructor(){\n\n    }\n\n    signBytes(chainID){\n\n    }\n\n    getType(){\n\n    }\n\n    rlpInput(){\n\n    }\n}\n\n// /**\n//  * Check if string is HEX, requires a 0x in front\n//  *\n//  * @method isHexStrict\n//  *\n//  * @param {String} hex to be checked\n//  *\n//  * @returns {Boolean}\n//  */\nconst isHexStrict = (hex) => {\n    return (isString(hex) || isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n *\n * @param {String} hex\n *\n * @returns {Array} the byte array\n */\nconst hexToBytes = (hex) => {\n    hex = hex.toString(16);\n\n    if (!isHexStrict(hex)) {\n        throw new Error(`Given value \"${hex}\" is not a valid hex string.`);\n    }\n\n    hex = hex.replace(/^0x/i, '');\n    hex = hex.length % 2 ? '0' + hex : hex;\n\n    let bytes = [];\n    for (let c = 0; c < hex.length; c += 2) {\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n    }\n\n    return bytes;\n};\n\n// Convert a byte array to a hex string\nconst bytesToHex = function(bytes) {\n    for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n    }\n    return hex.join(\"\");\n};\n\nBigNumber.prototype.pad = function(size) {\n    var s = String(this);\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n};\n\nconst bnFromString = str => {\n    const base = str.slice(0, 2) === \"0x\" ? 16 : 10;\n    const bigNum = new BigNumber(str, base);\n    const bigNumWithPad = \"0x\" + bigNum.pad(2);\n    return bigNumWithPad; // Jieyi: return \"0x00\" instead of \"0x\" to be compatible with the Golang/Java signature\n};\n\nconst encodeWei = (wei) =>{\n    if(wei === null || wei === undefined){\n        return Bytes.fromNat(\"0x0\");\n    }\n    else if(wei.isEqualTo(new BigNumber(0))){\n        return Bytes.fromNat(\"0x0\");\n    }\n    else{\n        return Bytes.fromNumber(wei);\n    }\n};\n\nclass Coins{\n    constructor(dneroWei, dtokenWei){\n        this.dneroWei = dneroWei;\n        this.dtokenWei = dtokenWei;\n    }\n\n    // encodeWei(wei){\n    //     if(wei === null || wei === undefined){\n    //         return Bytes.fromNat(\"0x0\");\n    //     }\n    //     else if(wei.isEqualTo(new BigNumber(0))){\n    //         return Bytes.fromNat(\"0x0\");\n    //     }\n    //     else{\n    //         return Bytes.fromNumber(wei);\n    //     }\n    // }\n\n    rlpInput(){\n\n        let rlpInput = [\n            encodeWei(this.dneroWei),\n            encodeWei(this.dtokenWei),\n            //(this.dneroWei.isEqualTo(new BigNumber(0))) ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.dneroWei),\n            //(this.dtokenWei.isEqualTo(new BigNumber(0))) ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.dtokenWei)\n        ];\n\n        return rlpInput;\n    }\n}\n\nclass TxInput{\n    constructor(address, dneroWei, dtokenWei, sequence) {\n        this.address = address;\n        this.sequence = sequence;\n        this.signature = \"\";\n\n        if(dneroWei || dtokenWei){\n            this.coins = new Coins(dneroWei, dtokenWei);\n        }\n        else{\n            //TODO should this be undefined or null?\n            this.coins = new Coins(null, null);\n        }\n    }\n\n    setSignature(signature) {\n        this.signature = signature;\n    }\n\n    rlpInput(){\n        let address = null;\n\n        if(this.address){\n            address = this.address.toLowerCase();\n        }\n        else{\n            address = Bytes.fromNat(\"0x0\");\n        }\n\n        let rplInput = [\n            address,\n            this.coins.rlpInput(),\n            Bytes.fromNumber(this.sequence),\n            this.signature\n        ];\n\n        return rplInput;\n    }\n}\n\nclass TxOutput {\n    constructor(address, dneroWei, dtokenWei) {\n        this.address = address;\n\n        if(dneroWei || dtokenWei){\n            this.coins = new Coins(dneroWei, dtokenWei);\n        }\n        else{\n            //TODO should this be undefined or null?\n            this.coins = new Coins(null, null);\n        }\n    }\n\n    rlpInput(){\n        let address = null;\n\n        if(this.address){\n            address = this.address.toLowerCase();\n        }\n        else{\n            //Empty address\n            address = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        let rplInput = [\n            address,\n            this.coins.rlpInput()\n        ];\n\n        return rplInput;\n    }\n}\n\nconst TxType = {\n    TxTypeCoinbase: 0,\n    TxTypeSlash: 1,\n    TxTypeSend: 2,\n    TxTypeReserveFund: 3,\n    TxTypeReleaseFund: 4,\n    TxTypeServicePayment: 5,\n    TxTypeSplitRule: 6,\n    TxTypeSmartContract: 7,\n    TxTypeDepositStake: 8,\n    TxTypeWithdrawStake: 9,\n    TxTypeDepositStakeV2: 10,\n};\n\nclass EthereumTx{\n    constructor(payload){\n        this.nonce = \"0x0\";\n        this.gasPrice = \"0x0\";\n        this.gas = \"0x0\";\n        this.to = \"0x0000000000000000000000000000000000000000\";\n        this.value = \"0x0\";\n        this.input = payload;\n    }\n\n    rlpInput() {\n        let rplInput= [\n            Bytes.fromNat(this.nonce),\n            Bytes.fromNat(this.gasPrice),\n            Bytes.fromNat(this.gas),\n            this.to.toLowerCase(),\n            Bytes.fromNat(this.value),\n            this.input,\n        ];\n\n        return rplInput;\n    }\n}\n\nclass SendTx extends Tx{\n    constructor(senderAddr, outputs, feeInDTokenWei, senderSequence){\n        super();\n\n        let totalDneroWeiBN = new BigNumber(0);\n        let totalDtokenWeiBN = new BigNumber(0);\n        let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : (new BigNumber(feeInDTokenWei));\n\n        for(var i = 0; i < outputs.length; i++){\n            let output = outputs[i];\n            let dneroWei = output.dneroWei;\n            let dtokenWei = output.dtokenWei;\n\n            let dneroWeiBN = BigNumber.isBigNumber(dneroWei) ? dneroWei : (new BigNumber(dneroWei));\n            let dtokenWeiBN = BigNumber.isBigNumber(dtokenWei) ? dtokenWei : (new BigNumber(dtokenWei));\n\n            totalDneroWeiBN = totalDneroWeiBN.plus(dneroWeiBN);\n            totalDtokenWeiBN = totalDtokenWeiBN.plus(dtokenWeiBN);\n        }\n\n        this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n\n        let txInput = new TxInput(senderAddr, totalDneroWeiBN, totalDtokenWeiBN.plus(feeInDTokenWeiBN), senderSequence);\n        this.inputs = [txInput];\n\n        this.outputs = [];\n        for(var j = 0; j < outputs.length; j++){\n            let output = outputs[j];\n            let address = output.address;\n            let dneroWei = output.dneroWei;\n            let dtokenWei = output.dtokenWei;\n\n            let dneroWeiBN = BigNumber.isBigNumber(dneroWei) ? dneroWei : (new BigNumber(dneroWei));\n            let dtokenWeiBN = BigNumber.isBigNumber(dtokenWei) ? dtokenWei : (new BigNumber(dtokenWei));\n\n            let txOutput = new TxOutput(address, dneroWeiBN, dtokenWeiBN);\n\n            this.outputs.push(txOutput);\n        }\n    }\n\n    setSignature(signature){\n        //TODO support multiple inputs\n        let input = this.inputs[0];\n        input.setSignature(signature);\n    }\n\n    signBytes(chainID){\n        let sigz = [];\n        //let input = this.inputs[0];\n\n        // Detach the existing signatures from the input if any, so that we don't sign the signature\n        //let originalSignature = input.signature;\n        //input.signature = \"\";\n\n        // Detach the existing signatures from the input if any, so that we don't sign the signature\n        for(var i = 0; i < this.inputs.length; i++){\n            let input = this.inputs[i];\n\n            sigz[i] = input.signature;\n            input.signature = \"\";\n        }\n\n        let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n        let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n        let encodedTx = RLP.encode(this.rlpInput());\n        let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2);\n\n        // For ethereum tx compatibility, encode the tx as the payload\n        let ethTxWrapper = new EthereumTx(payload);\n        let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n\n        console.log(\"SendTx :: signBytes :: txRawBytes = \" + signedBytes);\n\n        // Attach the original signature back to the inputs\n        //input.signature = originalSignature;\n\n        // Attach the original signature back to the inputs\n        for(var j = 0; j < this.inputs.length; j++){\n            let input = this.inputs[j];\n\n            input.signature = sigz[j];\n        }\n\n        return signedBytes;\n    }\n\n    getType(){\n        return TxType.TxTypeSend;\n    }\n\n    rlpInput(){\n        let numInputs = this.inputs.length;\n        let numOutputs = this.outputs.length;\n        let inputBytesArray = [];\n        let outputBytesArray = [];\n\n        for(let i = 0; i < numInputs; i ++) {\n            inputBytesArray[i] = this.inputs[i].rlpInput();\n        }\n\n        for (let i = 0; i < numOutputs; i ++) {\n            outputBytesArray[i] = this.outputs[i].rlpInput();\n        }\n\n        let rlpInput = [\n            this.fee.rlpInput(),\n            inputBytesArray,\n            outputBytesArray\n        ];\n\n        return rlpInput;\n    }\n}\n\nconst StakePurposes = {\n    StakeForValidator: 0,\n    StakeForSentry: 1,\n    StakeForEliteEdge: 2\n};\n\nclass StakeTx extends Tx{\n\n}\n\nclass DepositStakeTx extends StakeTx{\n    constructor(source, holderAddress, stakeInDneroWei, feeInDTokenWei, purpose, senderSequence){\n        super();\n\n        let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : (new BigNumber(feeInDTokenWei));\n        this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n\n        let stakeInDneroWeiBN = BigNumber.isBigNumber(stakeInDneroWei) ? stakeInDneroWei : (new BigNumber(stakeInDneroWei));\n        this.source = new TxInput(source, stakeInDneroWeiBN, null, senderSequence);\n\n        this.purpose = purpose;\n\n        //Parse out the info from the holder (summary) param\n        if(!holderAddress.startsWith('0x')){\n            holderAddress = \"0x\" + holderAddress;\n        }\n\n        //Ensure correct size\n        if(holderAddress.length !== 42) {\n            //TODO: throw error\n            console.log(\"Holder must be a valid address\");\n        }\n\n        this.holder = new TxOutput(holderAddress, null, null);\n    }\n\n    setSignature(signature){\n        let input = this.source;\n        input.setSignature(signature);\n    }\n\n    signBytes(chainID){\n        // Detach the existing signature from the source if any, so that we don't sign the signature\n        let sig = this.source.signature;\n\n        this.source.signature = \"\";\n\n        let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n        let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n        let encodedTx = RLP.encode(this.rlpInput());\n        let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2);\n\n        // For ethereum tx compatibility, encode the tx as the payload\n        let ethTxWrapper = new EthereumTx(payload);\n        let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n\n        // Attach the original signature back to the source\n        this.source.signature = sig;\n\n        return signedBytes;\n    }\n\n    getType(){\n        return TxType.TxTypeDepositStake;\n    }\n\n    rlpInput(){\n        let rlpInput = [\n            this.fee.rlpInput(),\n            this.source.rlpInput(),\n            this.holder.rlpInput(),\n\n            (this.purpose === 0 ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.purpose)),\n        ];\n\n        return rlpInput;\n    }\n}\n\nclass DepositStakeV2Tx extends StakeTx{\n    static isValidHolderSummary(purpose, holderSummary){\n        if(holderSummary){\n            let summary = holderSummary;\n            if(!holderSummary.startsWith('0x')){\n                summary = \"0x\" + holderSummary;\n            }\n\n            let expectedLen = 460; // Sentry Nodes\n            if(purpose === StakePurposes.StakeForEliteEdge){\n                expectedLen = 524;\n            }\n\n            return (summary.length === expectedLen);\n        }\n        else{\n            return false;\n        }\n    }\n\n    constructor(source, holderSummary, amount, feeInDTokenWei, purpose, senderSequence){\n        super();\n\n        let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : (new BigNumber(feeInDTokenWei));\n        this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n\n        let stakeInWeiBN = BigNumber.isBigNumber(amount) ? amount : (new BigNumber(amount));\n\n        if(purpose === StakePurposes.StakeForEliteEdge){\n            // DTOKEN staking\n            this.source = new TxInput(source, null, stakeInWeiBN, senderSequence);\n        }\n        else{\n            // DNERO staking\n            this.source = new TxInput(source, stakeInWeiBN, null, senderSequence);\n        }\n\n        this.purpose = purpose;\n\n        //Parse out the info from the holder (summary) param\n        if(!holderSummary.startsWith('0x')){\n            holderSummary = \"0x\" + holderSummary;\n        }\n\n        //Ensure correct size\n        if(!DepositStakeV2Tx.isValidHolderSummary(purpose, holderSummary)) {\n            //TODO: throw error\n            console.log(\"Holder must be a valid node summary\");\n        }\n\n        //let sentryKeyBytes = Bytes.fromString(holderSummary);\n        let nodeKeyBytes = Bytes.toArray(holderSummary);\n\n        //slice instead of subarray\n        let holderAddressBytes = nodeKeyBytes.slice(0, 20);\n\n        this.blsPubkeyBytes = nodeKeyBytes.slice(20, 68);\n        this.blsPopBytes = nodeKeyBytes.slice(68, 164);\n        this.holderSigBytes = nodeKeyBytes.slice(164, 229);\n\n        let holderAddress = Bytes.fromArray(holderAddressBytes);\n\n        this.holder = new TxOutput(holderAddress, null, null);\n    }\n\n    setSignature(signature){\n        let input = this.source;\n        input.setSignature(signature);\n    }\n\n    signBytes(chainID){\n        // Detach the existing signature from the source if any, so that we don't sign the signature\n        let sig = this.source.signature;\n\n\n        this.source.signature = \"\";\n\n        let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n        let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n        let encodedTx = RLP.encode(this.rlpInput());\n        let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2);\n\n        // For ethereum tx compatibility, encode the tx as the payload\n        let ethTxWrapper = new EthereumTx(payload);\n        let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n\n        // Attach the original signature back to the source\n        this.source.signature = sig;\n\n        return signedBytes;\n    }\n\n    getType(){\n        return TxType.TxTypeDepositStakeV2;\n    }\n\n    rlpInput(){\n        let rlpInput = [\n            this.fee.rlpInput(),\n            this.source.rlpInput(),\n            this.holder.rlpInput(),\n\n            Bytes.fromNumber(this.purpose),\n\n            Bytes.fromArray(this.blsPubkeyBytes),\n            Bytes.fromArray(this.blsPopBytes),\n            Bytes.fromArray(this.holderSigBytes)\n        ];\n\n        return rlpInput;\n    }\n}\n\nclass WithdrawStakeTx extends StakeTx{\n    constructor(source, holder, feeInDTokenWei, purpose, senderSequence){\n        super();\n\n        let feeInDTokenWeiBN = BigNumber.isBigNumber(feeInDTokenWei) ? feeInDTokenWei : (new BigNumber(feeInDTokenWei));\n        this.fee = new Coins(new BigNumber(0), feeInDTokenWeiBN);\n\n        this.source = new TxInput(source, null, null, senderSequence);\n\n        this.holder = new TxOutput(holder, null, null);\n\n        this.purpose = purpose;\n    }\n\n    setSignature(signature){\n        let input = this.source;\n        input.setSignature(signature);\n    }\n\n    signBytes(chainID){\n        // Detach the existing signature from the source if any, so that we don't sign the signature\n        let sig = this.source.signature;\n        this.source.signature = \"\";\n\n        let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n        let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n        let encodedTx = RLP.encode(this.rlpInput());\n        let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2);\n\n        // For ethereum tx compatibility, encode the tx as the payload\n        let ethTxWrapper = new EthereumTx(payload);\n        let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n\n        console.log(\"SendTx :: signBytes :: txRawBytes = \" + signedBytes);\n\n        // Attach the original signature back to the source\n        this.source.signature = sig;\n\n        return signedBytes;\n    }\n\n    getType(){\n        return TxType.TxTypeWithdrawStake;\n    }\n\n    rlpInput(){\n        let rlpInput = [\n            this.fee.rlpInput(),\n            this.source.rlpInput(),\n            this.holder.rlpInput(),\n\n            (this.purpose === 0 ? Bytes.fromNat(\"0x0\") : Bytes.fromNumber(this.purpose)),\n        ];\n\n        return rlpInput;\n    }\n}\n\nconst elliptic = (window.elliptic || require(\"elliptic\"));\nconst secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\nconst SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n\nconst sha3 = (value) => {\n    if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n        value = hexToBytes(value);\n    }\n\n    const returnValue = Hash.keccak256(value); // jshint ignore:line\n\n    if (returnValue === SHA3_NULL_S) {\n        return null;\n    } else {\n        return returnValue;\n    }\n};\n\nconst encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v]);\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const ecKey = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\"));\n  const signature = ecKey.sign(new Buffer(hash.slice(2), \"hex\"), { canonical: true });\n  return encodeSignature([\n      bnFromString(Bytes.fromNumber(addToV + signature.recoveryParam)),\n      Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))),\n      Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))\n    ]);\n};\n\nconst sign = makeSigner(0);\n\nclass TxSigner {\n\n    static signAndSerializeTx(chainID, tx, privateKey) {\n        let signedTx = this.signTx(chainID, tx, privateKey);\n        let signedRawBytes = this.serializeTx(signedTx);\n\n        return signedRawBytes;\n    }\n\n    static signTx(chainID, tx, privateKey) {\n        let txRawBytes = tx.signBytes(chainID);\n        let txHash = sha3(txRawBytes);\n        let signature = sign(txHash, privateKey);\n        tx.setSignature(signature);\n\n        return tx\n    }\n\n    static serializeTx(tx) {\n        let encodedTxType = RLP.encode(Bytes.fromNumber(tx.getType()));\n        let encodedTx = RLP.encode(tx.rlpInput());// this time encode with signature\n        let signedRawBytes = encodedTxType + encodedTx.slice(2);\n\n        return signedRawBytes;\n    }\n}\n\nvar Web3Utils = require('web3-utils');\n\nclass SmartContractTx extends Tx{\n    constructor(fromAddress, toAddress, gasLimit, gasPrice, data, value, senderSequence){\n        super();\n\n        let valueWeiBN = BigNumber.isBigNumber(value) ? value : (new BigNumber(value));\n\n        this.from = new TxInput(fromAddress, null, valueWeiBN, senderSequence);\n        this.to = new TxOutput(toAddress, null, null);\n\n        this.gasLimit = gasLimit;\n        this.gasPrice = gasPrice;\n\n        if(data.toLowerCase().startsWith(\"0x\") === false){\n            data = \"0x\" + data;\n        }\n\n        this.data = Bytes.toArray(data);\n    }\n\n    setSignature(signature){\n        let input = this.from;\n        input.setSignature(signature);\n    }\n\n    signBytes(chainID){\n        // Detach the existing signature from the source if any, so that we don't sign the signature\n        let sig = this.from.signature;\n\n        this.from.signature = \"\";\n\n        let encodedChainID = RLP.encode(Bytes.fromString(chainID));\n        let encodedTxType = RLP.encode(Bytes.fromNumber(this.getType()));\n        let encodedTx = RLP.encode(this.rlpInput());\n        let payload = encodedChainID + encodedTxType.slice(2) + encodedTx.slice(2);\n\n        // For ethereum tx compatibility, encode the tx as the payload\n        let ethTxWrapper = new EthereumTx(payload);\n        let signedBytes = RLP.encode(ethTxWrapper.rlpInput()); // the signBytes conforms to the Ethereum raw tx format\n\n        // Attach the original signature back to the source\n        this.from.signature = sig;\n\n        return signedBytes;\n    }\n\n    getType(){\n        return TxType.TxTypeSmartContract;\n    }\n\n    rlpInput(){\n        let rlpInput = [\n            this.from.rlpInput(),\n            this.to.rlpInput(),\n\n            Bytes.fromNumber(this.gasLimit),\n            encodeWei(this.gasPrice),\n\n            Bytes.fromArray(this.data)\n        ];\n\n        return rlpInput;\n    }\n}\n\nvar index = {\n    SendTx,\n    DepositStakeTx: DepositStakeTx,\n    DepositStakeV2Tx: DepositStakeV2Tx,\n    WithdrawStakeTx,\n    SmartContractTx,\n    TxSigner,\n    StakePurposes,\n    Utils: {\n        hexToBytes,\n        bytesToHex\n    }\n};\n\nexport default index;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}