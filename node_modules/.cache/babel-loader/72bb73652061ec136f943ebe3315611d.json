{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { createSelector } from 'reselect';\nimport _ from \"lodash\";\nimport TokenTypes from \"../../constants/TokenTypes\";\nimport Wallet from '../../services/Wallet';\n\nconst getTransactions = state => state.transactions.transactions;\n\nconst getLocalTransactionsByHash = state => state.transactions.localTransactionsByHash;\n\nconst getEthereumNetworkTransactionsByType = state => state.transactions.ethereumNetworkTransactionsByType;\n\nconst getWalletAddress = state => Wallet.getWalletAddress();\n\nfunction sortDneroNetworkTransactionOutputs(walletAddress, outputs) {\n  return _.sortBy(outputs, [function (output) {\n    //Ensure the output we care about is always first\n    if (output.address === walletAddress) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }]);\n}\n\nfunction transformDneroNetworkTransaction(walletAddress, transaction) {\n  let {\n    outputs\n  } = transaction;\n  outputs = sortDneroNetworkTransactionOutputs(walletAddress, outputs);\n  let output = null;\n  let address = null;\n\n  if (_.isNil(outputs)) {\n    //This tx is messed up, return null to prevent breaking the UI\n    return null;\n  }\n\n  output = outputs[0];\n  address = output['address'];\n  return Object.assign({}, transaction, {\n    bound: walletAddress === address ? \"inbound\" : \"outbound\",\n    outputs: outputs\n  });\n}\n\nfunction transformEthereumNetworkTransaction(walletAddress, transaction) {\n  return Object.assign({}, transaction, {\n    bound: walletAddress === transaction.to ? \"inbound\" : \"outbound\"\n  });\n}\n\nfunction getTransformedEthereumNetworkTransactions(walletAddress, type, transactionsByType, localTransactionsByHash) {\n  walletAddress = walletAddress ? walletAddress.toLowerCase() : null; //Merge these transactions and sort by timestamp\n\n  let scopedTransactions = transactionsByType[type];\n\n  let txTransformer = _.partial(transformEthereumNetworkTransaction, walletAddress);\n\n  let transactions = _(scopedTransactions).sortBy(tx => parseInt(tx.time_stamp)).reverse().map(txTransformer).value();\n\n  let transactionHashes = new Set(_.map(transactions, function (transaction) {\n    return transaction.hash;\n  }));\n\n  let localTransactions = _.filter(Object.values(localTransactionsByHash), function (transaction) {\n    return !transactionHashes.has(transaction.hash) && transaction[\"type\"] === type;\n  });\n\n  let allTransactions = _.flatten([localTransactions, transactions]); //Ensure all transactiosn are unique\n\n\n  return _.uniqBy(allTransactions, 'hash');\n}\n\nfunction getTransformedTransactions(walletAddress, txs, localTransactionsByHash) {\n  walletAddress = walletAddress ? walletAddress.toLowerCase() : null; //Merge these transactions and sort by timestamp\n\n  let isNotNil = _.negate(_.isNil); //returns true if the obj is NOT nil\n\n\n  let txTransformer = _.partial(transformDneroNetworkTransaction, walletAddress);\n\n  let transactions = _(txs).map(txTransformer).filter(isNotNil).sortBy(tx => parseInt(tx.timestamp)).reverse().value();\n\n  let transactionHashes = new Set(_.map(transactions, function (transaction) {\n    return transaction.hash;\n  }));\n\n  let localTransactions = _.filter(Object.values(localTransactionsByHash), function (transaction) {\n    return !transactionHashes.has(transaction.hash);\n  });\n\n  let allTransactions = _.flatten([localTransactions, transactions]); //Ensure all transactions are unique\n\n\n  return _.uniqBy(allTransactions, 'hash');\n}\n\nexport const getERC20Transactions = createSelector([getWalletAddress, getEthereumNetworkTransactionsByType, getLocalTransactionsByHash], (walletAddress, transactionsByType, localTransactionsByHash) => {\n  return getTransformedEthereumNetworkTransactions(walletAddress, TokenTypes.ERC20_DNERO, transactionsByType, localTransactionsByHash);\n});\nexport const getEthereumTransactions = createSelector([getWalletAddress, getEthereumNetworkTransactionsByType, getLocalTransactionsByHash], (walletAddress, transactionsByType, localTransactionsByHash) => {\n  return getTransformedEthereumNetworkTransactions(walletAddress, TokenTypes.ETHEREUM, transactionsByType, localTransactionsByHash);\n});\nexport const getDneroNetworkTransactions = createSelector([getWalletAddress, getTransactions, getLocalTransactionsByHash], (walletAddress, transactions, localTransactionsByHash) => {\n  return getTransformedTransactions(walletAddress, transactions, localTransactionsByHash);\n});\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(getTransactions, \"getTransactions\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getLocalTransactionsByHash, \"getLocalTransactionsByHash\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getEthereumNetworkTransactionsByType, \"getEthereumNetworkTransactionsByType\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getWalletAddress, \"getWalletAddress\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(sortDneroNetworkTransactionOutputs, \"sortDneroNetworkTransactionOutputs\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(transformDneroNetworkTransaction, \"transformDneroNetworkTransaction\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(transformEthereumNetworkTransaction, \"transformEthereumNetworkTransaction\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getTransformedEthereumNetworkTransactions, \"getTransformedEthereumNetworkTransactions\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getTransformedTransactions, \"getTransformedTransactions\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getERC20Transactions, \"getERC20Transactions\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getEthereumTransactions, \"getEthereumTransactions\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n  reactHotLoader.register(getDneroNetworkTransactions, \"getDneroNetworkTransactions\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["createSelector","_","TokenTypes","Wallet","getTransactions","state","transactions","getLocalTransactionsByHash","localTransactionsByHash","getEthereumNetworkTransactionsByType","ethereumNetworkTransactionsByType","getWalletAddress","sortDneroNetworkTransactionOutputs","walletAddress","outputs","sortBy","output","address","transformDneroNetworkTransaction","transaction","isNil","Object","assign","bound","transformEthereumNetworkTransaction","to","getTransformedEthereumNetworkTransactions","type","transactionsByType","toLowerCase","scopedTransactions","txTransformer","partial","tx","parseInt","time_stamp","reverse","map","value","transactionHashes","Set","hash","localTransactions","filter","values","has","allTransactions","flatten","uniqBy","getTransformedTransactions","txs","isNotNil","negate","timestamp","getERC20Transactions","ERC20_DNERO","getEthereumTransactions","ETHEREUM","getDneroNetworkTransactions"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js"],"sourcesContent":["import {createSelector} from 'reselect'\nimport _ from \"lodash\";\nimport TokenTypes from \"../../constants/TokenTypes\";\nimport Wallet from '../../services/Wallet'\n\nconst getTransactions = (state) => state.transactions.transactions;\nconst getLocalTransactionsByHash = (state) => state.transactions.localTransactionsByHash;\n\nconst getEthereumNetworkTransactionsByType = (state) => state.transactions.ethereumNetworkTransactionsByType;\n\nconst getWalletAddress = (state) => Wallet.getWalletAddress();\n\nfunction sortDneroNetworkTransactionOutputs(walletAddress, outputs){\n    return _.sortBy(outputs, [function (output) {\n        //Ensure the output we care about is always first\n        if (output.address === walletAddress) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }]);\n}\n\nfunction transformDneroNetworkTransaction(walletAddress, transaction) {\n    let {outputs} = transaction;\n    outputs = sortDneroNetworkTransactionOutputs(walletAddress, outputs);\n\n    let output = null;\n    let address = null;\n\n    if (_.isNil(outputs)) {\n        //This tx is messed up, return null to prevent breaking the UI\n        return null;\n    }\n\n    output = outputs[0];\n    address = output['address'];\n\n    return Object.assign({}, transaction, {\n        bound: (walletAddress === address ? \"inbound\" : \"outbound\"),\n        outputs: outputs\n    });\n}\n\nfunction transformEthereumNetworkTransaction(walletAddress, transaction) {\n    return Object.assign({}, transaction, {bound: (walletAddress === transaction.to ? \"inbound\" : \"outbound\")});\n}\n\nfunction getTransformedEthereumNetworkTransactions(walletAddress, type, transactionsByType, localTransactionsByHash) {\n    walletAddress = (walletAddress ? walletAddress.toLowerCase() : null);\n\n    //Merge these transactions and sort by timestamp\n    let scopedTransactions = transactionsByType[type];\n    let txTransformer = _.partial(transformEthereumNetworkTransaction, walletAddress);\n    let transactions = _(scopedTransactions)\n        .sortBy(tx => parseInt(tx.time_stamp))\n        .reverse()\n        .map(txTransformer)\n        .value();\n    let transactionHashes = new Set(_.map(transactions, function (transaction) {\n        return transaction.hash;\n    }));\n    let localTransactions = _.filter(Object.values(localTransactionsByHash), function (transaction) {\n        return !transactionHashes.has(transaction.hash) && transaction[\"type\"] === type;\n    });\n\n    let allTransactions = _.flatten([localTransactions, transactions]);\n\n    //Ensure all transactiosn are unique\n    return _.uniqBy(allTransactions, 'hash')\n}\n\nfunction getTransformedTransactions(walletAddress, txs, localTransactionsByHash) {\n    walletAddress = (walletAddress ? walletAddress.toLowerCase() : null);\n\n    //Merge these transactions and sort by timestamp\n    let isNotNil = _.negate(_.isNil);//returns true if the obj is NOT nil\n    let txTransformer = _.partial(transformDneroNetworkTransaction, walletAddress);\n    let transactions = _(txs)\n        .map(txTransformer)\n        .filter(isNotNil)\n        .sortBy(tx => parseInt(tx.timestamp))\n        .reverse()\n        .value();\n    let transactionHashes = new Set(_.map(transactions, function (transaction) {\n        return transaction.hash;\n    }));\n    let localTransactions = _.filter(Object.values(localTransactionsByHash), function (transaction) {\n        return !transactionHashes.has(transaction.hash);\n    });\n\n    let allTransactions = _.flatten([localTransactions, transactions]);\n\n    //Ensure all transactions are unique\n    return _.uniqBy(allTransactions, 'hash')\n}\n\nexport const getERC20Transactions = createSelector(\n    [getWalletAddress, getEthereumNetworkTransactionsByType, getLocalTransactionsByHash],\n    (walletAddress, transactionsByType, localTransactionsByHash) => {\n        return getTransformedEthereumNetworkTransactions(walletAddress, TokenTypes.ERC20_DNERO, transactionsByType, localTransactionsByHash);\n    }\n);\n\nexport const getEthereumTransactions = createSelector(\n    [getWalletAddress, getEthereumNetworkTransactionsByType, getLocalTransactionsByHash],\n    (walletAddress, transactionsByType, localTransactionsByHash) => {\n        return getTransformedEthereumNetworkTransactions(walletAddress, TokenTypes.ETHEREUM, transactionsByType, localTransactionsByHash);\n    }\n);\n\nexport const getDneroNetworkTransactions = createSelector(\n    [getWalletAddress, getTransactions, getLocalTransactionsByHash],\n    (walletAddress, transactions, localTransactionsByHash) => {\n        return getTransformedTransactions(walletAddress, transactions, localTransactionsByHash);\n    }\n);"],"mappings":"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"},"metadata":{},"sourceType":"module"}