{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport * as dnerojs from '@dnerolabs/dnero-js';\nimport { ethers } from 'ethers';\nimport _ from \"lodash\";\nimport Ethereum from './Ethereum';\nimport Dnero from \"./Dnero\";\nimport Api from './Api';\nimport TrezorConnect from 'trezor-connect';\nimport Trezor from './Trezor';\nimport Ledger from './Ledger';\nimport Eth from \"@ledgerhq/hw-app-eth\";\nimport TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\nimport TransportU2F from \"@ledgerhq/hw-transport-u2f\";\nimport DneroWalletController from \"../controllers/dnero-wallet\";\n\nconst ethUtil = require('ethereumjs-util'); //DO NOT TOUCH THESE!!!\n\n\nconst BaseDerivationPath = \"m/44'/60'/0'/0/\";\nexport const EthereumDerivationPath = \"m/44'/60'/0'/0/\";\nexport const EthereumOtherDerivationPath = \"m/44'/60'/0'/\";\nexport const EthereumLedgerLiveDerivationPath = \"m/44'/60'/\"; //END\n\nexport const DneroDevDerivationPath = \"m/44'/500'/\";\nconst MnemonicPath = \"m/44'/500'/0'/0/0\";\nexport const NumPathsPerPage = 5;\nexport const WalletUnlockStrategy = {\n  KEYSTORE_FILE: 'keystore-file',\n  MNEMONIC_PHRASE: 'mnemonic-phrase',\n  COLD_WALLET: 'cold-wallet',\n  PRIVATE_KEY: 'private-key'\n};\n\nconst getDneroWalletControllerState = () => {\n  try {\n    const preferencesControllerState = localStorage.getItem('preferencesController');\n    return {\n      preferencesController: _.isEmpty(preferencesControllerState) ? {} : JSON.parse(preferencesControllerState)\n    };\n  } catch (e) {\n    return {};\n  }\n};\n\nexport default class Wallet {\n  static setWallet(wallet) {\n    this._wallet = wallet;\n\n    if (wallet === null) {\n      //Also clear the encrypted keystore\n      Wallet.setKeystore(null);\n    }\n  }\n\n  static getWallet() {\n    return this._wallet;\n  }\n\n  static setKeystore(keystore) {\n    this._keystore = keystore;\n  }\n\n  static getKeystore() {\n    return this._keystore;\n  }\n\n  static getWalletAddress() {\n    return _.get(this._wallet, ['address'], null);\n  }\n\n  static getWalletPath() {\n    return _.get(this._wallet, ['path'], null);\n  }\n\n  static getWalletHardware() {\n    return _.get(this._wallet, ['hardware'], null);\n  }\n\n  static unlocked() {\n    return this._wallet !== null;\n  }\n\n  static encryptToKeystore(privateKey, password) {\n    let web3 = Ethereum.getWeb3();\n    return web3.eth.accounts.encrypt(privateKey, password);\n  }\n\n  static decryptFromKeystore(keystoreJsonV3, password) {\n    let web3 = Ethereum.getWeb3();\n    return web3.eth.accounts.decrypt(keystoreJsonV3, password);\n  }\n\n  static walletFromMnemonic(mnemonic) {\n    return ethers.Wallet.fromMnemonic(mnemonic, MnemonicPath);\n  }\n\n  static walletFromPrivateKey(privateKey) {\n    let web3 = Ethereum.getWeb3();\n    return web3.eth.accounts.privateKeyToAccount(privateKey);\n  }\n\n  static async walletFromTrezor(page) {\n    // window.__TREZOR_CONNECT_SRC = 'https://localhost:8088/'; //TODO: for dev\n    TrezorConnect.manifest({\n      email: 'support@dnerochain.org',\n      appUrl: 'https://wallet.dnerochain.org',\n      keepSession: true\n    });\n    let bundle = [];\n\n    for (var i = 0; i < 50; i++) {\n      bundle.push({\n        path: BaseDerivationPath + (page * NumPathsPerPage + i),\n        showOnTrezor: false\n      });\n    }\n\n    const result = await TrezorConnect.ethereumGetAddress({\n      bundle: bundle,\n      keepSession: true\n    });\n    return result;\n  }\n\n  static async walletFromLedger(page, derivationPath) {\n    let transport;\n\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n      transport = await TransportU2F.create();\n    } else {\n      transport = await TransportWebUSB.create();\n    }\n\n    const app = new Eth(transport);\n    let result = [],\n        res = {};\n\n    for (var i = 0; i < 5; i++) {\n      var path = \"\";\n\n      if (derivationPath === DneroDevDerivationPath) {\n        path = DneroDevDerivationPath + (page * NumPathsPerPage + i) + \"'/0/0\";\n      } else if (derivationPath === EthereumDerivationPath) {\n        path = EthereumDerivationPath + (page * NumPathsPerPage + i);\n      } else if (derivationPath === EthereumOtherDerivationPath) {\n        path = EthereumOtherDerivationPath + (page * NumPathsPerPage + i);\n      } else if (derivationPath === EthereumLedgerLiveDerivationPath) {\n        path = EthereumLedgerLiveDerivationPath + (page * NumPathsPerPage + i) + \"'/0/0\";\n      }\n\n      res = await app.getAddress(path, false, false);\n      result.push({\n        address: res.address,\n        serializedPath: path\n      });\n    } // transport.close();\n\n\n    return result;\n  }\n\n  static createWallet(password) {\n    const random = dnerojs.Wallet.createRandom();\n    const mnemonic = random.mnemonic.phrase;\n    let wallet = this.walletFromMnemonic(mnemonic);\n    let keystore = this.encryptToKeystore(wallet.privateKey, password);\n    return {\n      wallet: wallet,\n      keystore: keystore\n    };\n  }\n\n  static async unlockWallet(strategy, password, data) {\n    let wallet = null;\n    let {\n      keystore,\n      mnemonic,\n      privateKey,\n      hardware,\n      address,\n      path\n    } = data;\n\n    try {\n      if (strategy === WalletUnlockStrategy.KEYSTORE_FILE) {\n        if (typeof keystore === 'string' || keystore instanceof String) {\n          //Parse the keystore file\n          keystore = JSON.parse(keystore);\n        }\n\n        wallet = Wallet.decryptFromKeystore(keystore, password);\n        await this.controller.RPCApi.importAccount({\n          privateKey: wallet.privateKey\n        });\n      } else if (strategy === WalletUnlockStrategy.MNEMONIC_PHRASE) {\n        mnemonic = mnemonic.toString();\n        mnemonic = _.trim(mnemonic);\n        wallet = Wallet.walletFromMnemonic(mnemonic.toString());\n        await this.controller.RPCApi.importAccount({\n          privateKey: wallet.privateKey\n        });\n      } else if (strategy === WalletUnlockStrategy.PRIVATE_KEY) {\n        privateKey = _.trim(privateKey);\n\n        if (privateKey.startsWith(\"0x\") === false) {\n          privateKey = \"0x\" + privateKey;\n        }\n\n        let privateKeyBuffer = ethUtil.toBuffer(privateKey);\n\n        if (!ethUtil.isValidPrivate(privateKeyBuffer)) {\n          throw new Error(\"Private key does not satisfy the curve requirements (ie. it is invalid)\");\n        }\n\n        wallet = Wallet.walletFromPrivateKey(privateKey);\n        await this.controller.RPCApi.importAccount({\n          privateKey: privateKey\n        });\n      } else if (strategy === WalletUnlockStrategy.COLD_WALLET) {\n        wallet = {};\n        wallet.address = address;\n      }\n\n      if (wallet) {\n        //Only store the address in memory\n        Wallet.setWallet({\n          address: wallet.address,\n          path: path,\n          hardware: hardware\n        });\n\n        if (strategy !== WalletUnlockStrategy.COLD_WALLET && (keystore === null || keystore === undefined)) {\n          //The user is restoring a wallet, let's encrypt their keystore using their session password\n          keystore = Wallet.encryptToKeystore(wallet.privateKey, password);\n        }\n\n        Wallet.setKeystore(keystore);\n      }\n\n      return wallet;\n    } catch (e) {\n      let message = null;\n\n      if (strategy === WalletUnlockStrategy.KEYSTORE_FILE) {\n        message = \"Wrong password OR invalid keystore.\";\n      } else if (strategy === WalletUnlockStrategy.MNEMONIC_PHRASE) {\n        message = \"No wallet found for this mnemonic phrase.\";\n      } else if (strategy === WalletUnlockStrategy.PRIVATE_KEY) {\n        message = \"No wallet found for this private key.\";\n      }\n\n      throw new Error(message);\n    }\n  }\n\n  static async getDneroTxSequence(address, network) {\n    let response = await Api.fetchSequence(address, {\n      network: network\n    });\n    let responseJSON = await response.json();\n    let sequence = parseInt(responseJSON['sequence']) + 1;\n    return sequence;\n  }\n\n  static verifyPassword(password) {\n    try {\n      let hardware = Wallet.getWalletHardware();\n\n      if (hardware === \"trezor\") {\n        return true;\n      } else if (hardware === \"ledger\") {\n        return true;\n      } else {\n        let keystore = Wallet.getKeystore();\n        let wallet = Wallet.decryptFromKeystore(keystore, password);\n        return !!wallet;\n      }\n    } catch (e) {\n      return false;\n    }\n  }\n\n  static async signTransaction(network, unsignedTx, password) {\n    let hardware = Wallet.getWalletHardware();\n\n    if (hardware === \"trezor\") {\n      return Trezor.signTransaction(unsignedTx);\n    } else if (hardware === \"ledger\") {\n      return Ledger.signTransaction(unsignedTx);\n    } else {\n      let keystore = Wallet.getKeystore();\n      let wallet = Wallet.decryptFromKeystore(keystore, password);\n\n      if (wallet) {\n        //User had the correct password\n        return Dnero.signTransaction(unsignedTx, wallet.privateKey);\n      } else {\n        throw new Error('Wrong password. Your transaction could not be signed.');\n      }\n    }\n  }\n\n  static exportKeystore(currentPassword, newPassword) {\n    let keystore = Wallet.getKeystore();\n    let wallet = Wallet.decryptFromKeystore(keystore, currentPassword);\n\n    if (wallet) {\n      let keystore = Wallet.encryptToKeystore(wallet.privateKey, newPassword);\n      return keystore;\n    } else {\n      throw new Error('Wrong password.  Your keystore could not be exported.');\n    }\n  }\n\n}\nWallet._wallet = null;\nWallet._keystore = null;\nWallet.controller = new DneroWalletController({\n  initState: getDneroWalletControllerState()\n});\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(BaseDerivationPath, \"BaseDerivationPath\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(EthereumDerivationPath, \"EthereumDerivationPath\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(EthereumOtherDerivationPath, \"EthereumOtherDerivationPath\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(EthereumLedgerLiveDerivationPath, \"EthereumLedgerLiveDerivationPath\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(DneroDevDerivationPath, \"DneroDevDerivationPath\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(MnemonicPath, \"MnemonicPath\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(NumPathsPerPage, \"NumPathsPerPage\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(WalletUnlockStrategy, \"WalletUnlockStrategy\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(getDneroWalletControllerState, \"getDneroWalletControllerState\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n  reactHotLoader.register(Wallet, \"Wallet\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["dnerojs","ethers","_","Ethereum","Dnero","Api","TrezorConnect","Trezor","Ledger","Eth","TransportWebUSB","TransportU2F","DneroWalletController","ethUtil","require","BaseDerivationPath","EthereumDerivationPath","EthereumOtherDerivationPath","EthereumLedgerLiveDerivationPath","DneroDevDerivationPath","MnemonicPath","NumPathsPerPage","WalletUnlockStrategy","KEYSTORE_FILE","MNEMONIC_PHRASE","COLD_WALLET","PRIVATE_KEY","getDneroWalletControllerState","preferencesControllerState","localStorage","getItem","preferencesController","isEmpty","JSON","parse","e","Wallet","setWallet","wallet","_wallet","setKeystore","getWallet","keystore","_keystore","getKeystore","getWalletAddress","get","getWalletPath","getWalletHardware","unlocked","encryptToKeystore","privateKey","password","web3","getWeb3","eth","accounts","encrypt","decryptFromKeystore","keystoreJsonV3","decrypt","walletFromMnemonic","mnemonic","fromMnemonic","walletFromPrivateKey","privateKeyToAccount","walletFromTrezor","page","manifest","email","appUrl","keepSession","bundle","i","push","path","showOnTrezor","result","ethereumGetAddress","walletFromLedger","derivationPath","transport","navigator","userAgent","toLowerCase","indexOf","create","app","res","getAddress","address","serializedPath","createWallet","random","createRandom","phrase","unlockWallet","strategy","data","hardware","String","controller","RPCApi","importAccount","toString","trim","startsWith","privateKeyBuffer","toBuffer","isValidPrivate","Error","undefined","message","getDneroTxSequence","network","response","fetchSequence","responseJSON","json","sequence","parseInt","verifyPassword","signTransaction","unsignedTx","exportKeystore","currentPassword","newPassword","initState"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/services/Wallet.js"],"sourcesContent":["import * as dnerojs from '@dnerolabs/dnero-js';\nimport { ethers } from 'ethers';\nimport _ from \"lodash\";\nimport Ethereum from './Ethereum'\nimport Dnero from \"./Dnero\";\nimport Api from './Api';\nimport TrezorConnect from 'trezor-connect';\nimport Trezor from './Trezor';\nimport Ledger from './Ledger';\nimport Eth from \"@ledgerhq/hw-app-eth\";\nimport TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\nimport TransportU2F from \"@ledgerhq/hw-transport-u2f\";\nimport DneroWalletController from \"../controllers/dnero-wallet\";\n\nconst ethUtil = require('ethereumjs-util');\n\n//DO NOT TOUCH THESE!!!\nconst BaseDerivationPath = \"m/44'/60'/0'/0/\";\nexport const EthereumDerivationPath = \"m/44'/60'/0'/0/\";\nexport const EthereumOtherDerivationPath = \"m/44'/60'/0'/\";\nexport const EthereumLedgerLiveDerivationPath = \"m/44'/60'/\";\n//END\nexport const DneroDevDerivationPath = \"m/44'/500'/\";\n\nconst MnemonicPath = \"m/44'/500'/0'/0/0\";\n\nexport const NumPathsPerPage = 5;\n\nexport const WalletUnlockStrategy = {\n    KEYSTORE_FILE: 'keystore-file',\n    MNEMONIC_PHRASE: 'mnemonic-phrase',\n    COLD_WALLET: 'cold-wallet',\n    PRIVATE_KEY: 'private-key',\n};\n\nconst getDneroWalletControllerState = () => {\n    try {\n        const preferencesControllerState = localStorage.getItem('preferencesController');\n\n        return {\n            preferencesController: (_.isEmpty(preferencesControllerState) ? {} : JSON.parse(preferencesControllerState))\n        }\n    }\n    catch (e) {\n        return {}\n    }\n}\n\nexport default class Wallet {\n    static _wallet = null;\n    static _keystore = null;\n    static controller = new DneroWalletController({\n        initState: getDneroWalletControllerState()\n    });\n\n    static setWallet(wallet){\n        this._wallet = wallet;\n\n        if(wallet === null){\n            //Also clear the encrypted keystore\n            Wallet.setKeystore(null);\n        }\n    }\n\n    static getWallet(){\n        return this._wallet;\n    }\n\n    static setKeystore(keystore){\n        this._keystore = keystore;\n    }\n\n    static getKeystore(){\n        return this._keystore;\n    }\n\n    static getWalletAddress(){\n        return _.get(this._wallet, ['address'], null);\n    }\n\n    static getWalletPath(){\n        return _.get(this._wallet, ['path'], null);\n    }\n\n    static getWalletHardware(){\n        return _.get(this._wallet, ['hardware'], null);\n    }\n\n    static unlocked(){\n        return (this._wallet !== null);\n    }\n\n    static encryptToKeystore(privateKey, password){\n        let web3 = Ethereum.getWeb3();\n\n        return web3.eth.accounts.encrypt(privateKey, password);\n    }\n\n    static decryptFromKeystore(keystoreJsonV3, password){\n        let web3 = Ethereum.getWeb3();\n\n        return web3.eth.accounts.decrypt(keystoreJsonV3, password);\n    }\n\n    static walletFromMnemonic(mnemonic){\n        return ethers.Wallet.fromMnemonic(mnemonic, MnemonicPath);\n    }\n\n    static walletFromPrivateKey(privateKey){\n        let web3 = Ethereum.getWeb3();\n\n        return web3.eth.accounts.privateKeyToAccount(privateKey);\n    }\n\n    static async walletFromTrezor(page){\n        // window.__TREZOR_CONNECT_SRC = 'https://localhost:8088/'; //TODO: for dev\n\n        TrezorConnect.manifest({\n            email: 'support@dnerochain.org',\n            appUrl: 'https://wallet.dnerochain.org',\n            keepSession: true\n        });\n\n\n        let bundle = [];\n        for(var i = 0; i < 50; i++){\n            bundle.push({ path: BaseDerivationPath + (page * NumPathsPerPage + i), showOnTrezor: false });\n        }\n\n        const result = await TrezorConnect.ethereumGetAddress({\n            bundle: bundle,\n            keepSession: true\n        });\n\n        return result;\n    }\n\n    static async walletFromLedger(page, derivationPath){\n        let transport;\n        if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1){\n            transport = await TransportU2F.create();\n        }\n        else {\n            transport = await TransportWebUSB.create();\n        }\n        const app = new Eth(transport);\n\n        let result = [], res = {};\n        for(var i = 0; i < 5; i++){\n            var path = \"\";\n            if (derivationPath === DneroDevDerivationPath) {\n                path = DneroDevDerivationPath + (page * NumPathsPerPage + i) + \"'/0/0\";\n            } else if(derivationPath === EthereumDerivationPath){\n                path = EthereumDerivationPath + (page * NumPathsPerPage + i);\n            }\n            else if(derivationPath === EthereumOtherDerivationPath){\n                path = EthereumOtherDerivationPath + (page * NumPathsPerPage + i);\n            }\n            else if(derivationPath === EthereumLedgerLiveDerivationPath){\n                path = EthereumLedgerLiveDerivationPath + (page * NumPathsPerPage + i) + \"'/0/0\";\n            }\n            res = await app.getAddress(path, false, false);\n\n            result.push({address: res.address, serializedPath: path});\n\n        }\n\n        // transport.close();\n        return result;\n    }\n\n    static createWallet(password){\n        const random = dnerojs.Wallet.createRandom();\n        const mnemonic = random.mnemonic.phrase;\n        let wallet = this.walletFromMnemonic(mnemonic);\n        let keystore = this.encryptToKeystore(wallet.privateKey, password);\n\n        return {\n            wallet: wallet,\n            keystore: keystore\n        };\n    }\n\n    static async unlockWallet(strategy, password, data){\n        let wallet = null;\n        let { keystore, mnemonic, privateKey, hardware, address, path } = data;\n\n        try{\n            if(strategy === WalletUnlockStrategy.KEYSTORE_FILE){\n                if(typeof keystore === 'string' || keystore instanceof String){\n                    //Parse the keystore file\n                    keystore = JSON.parse(keystore);\n                }\n\n                wallet = Wallet.decryptFromKeystore(keystore, password);\n\n                await this.controller.RPCApi.importAccount({\n                    privateKey: wallet.privateKey\n                });\n            }\n            else if(strategy === WalletUnlockStrategy.MNEMONIC_PHRASE){\n                mnemonic = mnemonic.toString();\n                mnemonic = _.trim(mnemonic);\n\n                wallet = Wallet.walletFromMnemonic(mnemonic.toString());\n\n                await this.controller.RPCApi.importAccount({\n                    privateKey: wallet.privateKey\n                });\n            }\n            else if(strategy === WalletUnlockStrategy.PRIVATE_KEY){\n                privateKey = _.trim(privateKey);\n\n                if(privateKey.startsWith(\"0x\") === false){\n                    privateKey = \"0x\" + privateKey;\n                }\n\n                let privateKeyBuffer = ethUtil.toBuffer(privateKey);\n\n                if(!ethUtil.isValidPrivate(privateKeyBuffer)){\n                    throw new Error(\"Private key does not satisfy the curve requirements (ie. it is invalid)\");\n                }\n\n                wallet = Wallet.walletFromPrivateKey(privateKey);\n\n                await this.controller.RPCApi.importAccount({\n                    privateKey: privateKey\n                });\n            }\n            else if(strategy === WalletUnlockStrategy.COLD_WALLET){\n                wallet = {};\n                wallet.address = address;\n            }\n\n            if(wallet){\n                //Only store the address in memory\n                Wallet.setWallet({address: wallet.address, path: path, hardware: hardware});\n\n                if(strategy !== WalletUnlockStrategy.COLD_WALLET && (keystore === null || keystore === undefined)){\n                    //The user is restoring a wallet, let's encrypt their keystore using their session password\n                    keystore = Wallet.encryptToKeystore(wallet.privateKey, password);\n                }\n\n                Wallet.setKeystore(keystore);\n            }\n\n            return wallet;\n        }\n        catch (e) {\n            let message = null;\n\n            if(strategy === WalletUnlockStrategy.KEYSTORE_FILE){\n                message = \"Wrong password OR invalid keystore.\";\n            }\n            else if(strategy === WalletUnlockStrategy.MNEMONIC_PHRASE){\n                message = \"No wallet found for this mnemonic phrase.\";\n            }\n            else if(strategy === WalletUnlockStrategy.PRIVATE_KEY){\n                message = \"No wallet found for this private key.\";\n            }\n\n            throw new Error(message);\n        }\n    }\n\n    static async getDneroTxSequence(address, network){\n        let response = await Api.fetchSequence(address, {network: network});\n        let responseJSON = await response.json();\n        let sequence = parseInt(responseJSON['sequence']) + 1;\n\n        return sequence;\n    }\n\n    static verifyPassword(password){\n        try {\n            let hardware = Wallet.getWalletHardware();\n\n            if(hardware === \"trezor\"){\n                return true;\n            }\n            else if(hardware === \"ledger\"){\n                return true;\n            }\n            else {\n                let keystore = Wallet.getKeystore();\n                let wallet = Wallet.decryptFromKeystore(keystore, password);\n\n                return !!wallet;\n            }\n        }\n        catch (e) {\n            return false;\n        }\n    }\n\n    static async signTransaction(network, unsignedTx, password){\n        let hardware = Wallet.getWalletHardware();\n\n        if(hardware === \"trezor\"){\n            return Trezor.signTransaction(unsignedTx);\n        }\n        else if(hardware === \"ledger\"){\n            return Ledger.signTransaction(unsignedTx);\n        }\n        else {\n            let keystore = Wallet.getKeystore();\n            let wallet = Wallet.decryptFromKeystore(keystore, password);\n\n            if(wallet){\n                //User had the correct password\n                return Dnero.signTransaction(unsignedTx, wallet.privateKey);\n            }\n            else{\n                throw new Error('Wrong password. Your transaction could not be signed.');\n            }\n        }\n    }\n\n    static exportKeystore(currentPassword, newPassword){\n        let keystore = Wallet.getKeystore();\n        let wallet = Wallet.decryptFromKeystore(keystore, currentPassword);\n\n        if(wallet){\n            let keystore = Wallet.encryptToKeystore(wallet.privateKey, newPassword);\n\n            return keystore;\n        }\n        else{\n            throw new Error('Wrong password.  Your keystore could not be exported.');\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}