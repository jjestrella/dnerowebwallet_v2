{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport * as actionTypes from \"../types/Wallet\";\nimport { zipMap } from \"../../utils/Utils\";\nimport Config from '../../Config';\nconst INITIAL_STATE = {\n  dneroWallet: null,\n  network: Config.defaultDneroChainID,\n  isFetchingBalances: false,\n  isFetchingEthereumBalances: false,\n  address: null,\n  name: null,\n  //Dnero\n  balances: [],\n  balancesByType: {},\n  balancesRefreshedAt: null,\n  //Legacy\n  ethereumBalances: [],\n  ethereumBalancesByType: {}\n};\nexport const walletReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case actionTypes.SET_NETWORK:\n      {\n        return Object.assign({}, state, {\n          network: action.network\n        });\n      }\n\n    case actionTypes.FETCH_WALLET_ETHEREUM_BALANCES_START:\n      {\n        return Object.assign({}, state, {\n          isFetchingEthereumBalances: true\n        });\n      }\n\n    case actionTypes.FETCH_WALLET_ETHEREUM_BALANCES_END:\n      {\n        return Object.assign({}, state, {\n          isFetchingEthereumBalances: false\n        });\n      }\n\n    case actionTypes.FETCH_WALLET_ETHEREUM_BALANCES_SUCCESS:\n      {\n        let body = action.response.body;\n        let balances = body.balances;\n        return Object.assign({}, state, {\n          ethereumBalances: balances,\n          ethereumBalancesByType: zipMap(balances.map(_ref => {\n            let {\n              type\n            } = _ref;\n            return type;\n          }), balances.map(_ref2 => {\n            let {\n              value\n            } = _ref2;\n            return value;\n          }))\n        });\n      }\n\n    case actionTypes.FETCH_WALLET_BALANCES_START:\n      {\n        return Object.assign({}, state, {\n          isFetchingBalances: true\n        });\n      }\n\n    case actionTypes.FETCH_WALLET_BALANCES_END:\n      {\n        return Object.assign({}, state, {\n          isFetchingBalances: false\n        });\n      }\n\n    case actionTypes.FETCH_WALLET_BALANCES_SUCCESS:\n      {\n        let body = action.response.body;\n        let balances = body.balances;\n        return Object.assign({}, state, {\n          balances: balances,\n          balancesByType: zipMap(balances.map(_ref3 => {\n            let {\n              type\n            } = _ref3;\n            return type;\n          }), balances.map(_ref4 => {\n            let {\n              value\n            } = _ref4;\n            return value;\n          })),\n          balancesRefreshedAt: new Date()\n        });\n      }\n\n    case actionTypes.SET_WALLET_ADDRESS:\n      {\n        return Object.assign({}, state, {\n          address: action.address\n        });\n      }\n    //Reset all state (useful when recovering a wallet which may have another wallet's state stored in memory))\n\n    case actionTypes.RESET:\n      {\n        return INITIAL_STATE;\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n};\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(INITIAL_STATE, \"INITIAL_STATE\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/reducers/Wallet.js\");\n  reactHotLoader.register(walletReducer, \"walletReducer\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/reducers/Wallet.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["actionTypes","zipMap","Config","INITIAL_STATE","dneroWallet","network","defaultDneroChainID","isFetchingBalances","isFetchingEthereumBalances","address","name","balances","balancesByType","balancesRefreshedAt","ethereumBalances","ethereumBalancesByType","walletReducer","state","action","type","SET_NETWORK","Object","assign","FETCH_WALLET_ETHEREUM_BALANCES_START","FETCH_WALLET_ETHEREUM_BALANCES_END","FETCH_WALLET_ETHEREUM_BALANCES_SUCCESS","body","response","map","value","FETCH_WALLET_BALANCES_START","FETCH_WALLET_BALANCES_END","FETCH_WALLET_BALANCES_SUCCESS","Date","SET_WALLET_ADDRESS","RESET"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/reducers/Wallet.js"],"sourcesContent":["import * as actionTypes from \"../types/Wallet\";\nimport { zipMap } from \"../../utils/Utils\";\nimport Config from '../../Config';\n\nconst INITIAL_STATE = {\n    dneroWallet: null,\n\n    network: Config.defaultDneroChainID,\n\n    isFetchingBalances : false,\n    isFetchingEthereumBalances : false,\n\n    address: null,\n    name: null,\n\n    //Dnero\n    balances: [],\n    balancesByType: {},\n    balancesRefreshedAt: null,\n\n    //Legacy\n    ethereumBalances:[],\n    ethereumBalancesByType: {},\n};\n\nexport const walletReducer = (state = INITIAL_STATE, action) => {\n    switch (action.type) {\n        case actionTypes.SET_NETWORK:{\n            return Object.assign({}, state, {\n                network: action.network\n            });\n        }\n        case actionTypes.FETCH_WALLET_ETHEREUM_BALANCES_START:{\n            return Object.assign({}, state, {\n                isFetchingEthereumBalances: true\n            });\n        }\n        case actionTypes.FETCH_WALLET_ETHEREUM_BALANCES_END:{\n            return Object.assign({}, state, {\n                isFetchingEthereumBalances: false\n            });\n        }\n        case actionTypes.FETCH_WALLET_ETHEREUM_BALANCES_SUCCESS:{\n            let body = action.response.body;\n            let balances = body.balances;\n\n            return Object.assign({}, state, {\n                ethereumBalances: balances,\n                ethereumBalancesByType: zipMap(balances.map(({ type }) => type), balances.map(({ value }) => value))\n            });\n        }\n\n        case actionTypes.FETCH_WALLET_BALANCES_START:{\n            return Object.assign({}, state, {\n                isFetchingBalances: true\n            });\n        }\n        case actionTypes.FETCH_WALLET_BALANCES_END:{\n            return Object.assign({}, state, {\n                isFetchingBalances: false\n            });\n        }\n        case actionTypes.FETCH_WALLET_BALANCES_SUCCESS:{\n            let body = action.response.body;\n            let balances = body.balances;\n\n            return Object.assign({}, state, {\n                balances: balances,\n                balancesByType: zipMap(balances.map(({ type }) => type), balances.map(({ value }) => value)),\n                balancesRefreshedAt: new Date()\n            });\n        }\n\n        case actionTypes.SET_WALLET_ADDRESS:{\n            return Object.assign({}, state, {\n                address: action.address\n            });\n        }\n\n        //Reset all state (useful when recovering a wallet which may have another wallet's state stored in memory))\n        case actionTypes.RESET:{\n            return INITIAL_STATE;\n        }\n\n        default:{\n            return state\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}