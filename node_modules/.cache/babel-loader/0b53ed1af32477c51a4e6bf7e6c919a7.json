{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport _ from 'lodash';\nimport Trezor from \"../../services/Trezor\";\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst HDKey = require('hdkey');\n\nconst TrezorConnect = require('trezor-connect').default;\n\nconst hdPathString = `m/44'/60'/0'/0`;\nconst keyringType = 'Trezor Hardware';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\nconst DELAY_BETWEEN_POPUPS = 1000;\nconst TREZOR_CONNECT_MANIFEST = {\n  email: 'support@dnerochain.org',\n  appUrl: 'https://wallet.dnerochain.org',\n  keepSession: true\n};\n\nclass TrezorKeyring extends EventEmitter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.type = keyringType;\n    this.accounts = [];\n    this.hdk = new HDKey();\n    this.page = 0;\n    this.perPage = 5;\n    this.unlockedAccount = 0;\n    this.paths = {};\n    this.deserialize(opts);\n    TrezorConnect.manifest(TREZOR_CONNECT_MANIFEST);\n  }\n\n  serialize() {\n    return Promise.resolve({\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      page: this.page,\n      paths: this.paths,\n      perPage: this.perPage,\n      unlockedAccount: this.unlockedAccount\n    });\n  }\n\n  deserialize() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.hdPath = opts.hdPath || hdPathString;\n    this.accounts = opts.accounts || [];\n    this.page = opts.page || 0;\n    this.perPage = opts.perPage || 5;\n    return Promise.resolve();\n  }\n\n  isUnlocked() {\n    return !!(this.hdk && this.hdk.publicKey);\n  }\n\n  unlock() {\n    if (this.isUnlocked()) return Promise.resolve('already unlocked');\n    return new Promise((resolve, reject) => {\n      TrezorConnect.getPublicKey({\n        path: this.hdPath,\n        coin: 'ETH'\n      }).then(response => {\n        if (response.success) {\n          this.hdk.publicKey = new Buffer(response.payload.publicKey, 'hex');\n          this.hdk.chainCode = new Buffer(response.payload.chainCode, 'hex');\n          resolve('just unlocked');\n        } else {\n          reject(new Error(response.payload && response.payload.error || 'Unknown error'));\n        }\n      }).catch(e => {\n        reject(new Error(e && e.toString() || 'Unknown error'));\n      });\n    });\n  }\n\n  setAccountToUnlock(index) {\n    this.unlockedAccount = parseInt(index, 10);\n  }\n\n  addAccounts() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return new Promise((resolve, reject) => {\n      this.unlock().then(_ => {\n        const from = this.unlockedAccount;\n        const to = from + n;\n        this.accounts = [];\n\n        for (let i = from; i < to; i++) {\n          const address = this._addressFromIndex(pathBase, i);\n\n          this.accounts.push(address);\n          this.page = 0;\n        }\n\n        resolve(this.accounts);\n      }).catch(e => {\n        reject(e);\n      });\n    });\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this._getPage(1);\n  }\n\n  getNextPage() {\n    return this._getPage(1);\n  }\n\n  getPreviousPage() {\n    return this._getPage(-1);\n  }\n\n  _getPage(increment) {\n    this.page += increment;\n\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n\n    return new Promise((resolve, reject) => {\n      this.unlock().then(_ => {\n        const from = (this.page - 1) * this.perPage;\n        const to = from + this.perPage;\n        const accounts = [];\n\n        for (let i = from; i < to; i++) {\n          const address = this._addressFromIndex(pathBase, i);\n\n          accounts.push({\n            address: address,\n            balance: null,\n            index: i\n          });\n          this.paths[ethUtil.toChecksumAddress(address)] = i;\n        }\n\n        resolve(accounts);\n      }).catch(e => {\n        reject(e);\n      });\n    });\n  }\n\n  getAccounts() {\n    return Promise.resolve(this.accounts.slice());\n  }\n\n  removeAccount(address) {\n    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n\n    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());\n  }\n\n  async signAndSendTransaction(fromAddress, transaction, provider) {\n    const unlockResult = await this.unlock();\n\n    if (_.isNil(transaction.getSequenceOverride())) {\n      let sequence = await provider.getTransactionCount(fromAddress);\n      sequence = sequence + 1;\n      transaction.setSequence(sequence);\n    }\n\n    transaction.setFrom(ethUtil.toChecksumAddress(fromAddress));\n    const signedTxRaw = await Trezor.signTransaction(transaction);\n    const result = provider.sendTransaction(signedTxRaw);\n    return Promise.resolve(result);\n  }\n\n  signMessage(withAccount, data) {\n    return Promise.reject(new Error('Not supported on this device'));\n  } // For personal_sign, we need to prefix the message:\n\n\n  signPersonalMessage(withAccount, message) {\n    return Promise.reject(new Error('Not supported on this device'));\n  }\n\n  signTypedData(withAccount, typedData) {\n    // Waiting on trezor to enable this\n    return Promise.reject(new Error('Not supported on this device'));\n  }\n\n  exportAccount(address) {\n    return Promise.reject(new Error('Not supported on this device'));\n  }\n\n  forgetDevice() {\n    this.accounts = [];\n    this.hdk = new HDKey();\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.paths = {};\n  }\n  /* PRIVATE METHODS */\n\n\n  _normalize(buf) {\n    return ethUtil.bufferToHex(buf).toString();\n  }\n\n  _addressFromIndex(pathBase, i) {\n    const dkey = this.hdk.derive(`${pathBase}/${i}`);\n    const address = ethUtil.publicToAddress(dkey.publicKey, true).toString('hex');\n    return ethUtil.toChecksumAddress(address).toLowerCase();\n  }\n\n  _pathFromAddress(address) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address);\n    let index = this.paths[checksummedAddress];\n\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address');\n    }\n\n    return `${this.hdPath}/${index}`;\n  }\n\n  // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n\n}\n\nTrezorKeyring.type = keyringType;\nconst _default = TrezorKeyring;\nexport default _default;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(TrezorConnect, \"TrezorConnect\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(hdPathString, \"hdPathString\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(keyringType, \"keyringType\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(pathBase, \"pathBase\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(MAX_INDEX, \"MAX_INDEX\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(DELAY_BETWEEN_POPUPS, \"DELAY_BETWEEN_POPUPS\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(TREZOR_CONNECT_MANIFEST, \"TREZOR_CONNECT_MANIFEST\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(TrezorKeyring, \"TrezorKeyring\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n  reactHotLoader.register(_default, \"default\", \"/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["_","Trezor","EventEmitter","require","ethUtil","HDKey","TrezorConnect","default","hdPathString","keyringType","pathBase","MAX_INDEX","DELAY_BETWEEN_POPUPS","TREZOR_CONNECT_MANIFEST","email","appUrl","keepSession","TrezorKeyring","constructor","opts","type","accounts","hdk","page","perPage","unlockedAccount","paths","deserialize","manifest","serialize","Promise","resolve","hdPath","isUnlocked","publicKey","unlock","reject","getPublicKey","path","coin","then","response","success","Buffer","payload","chainCode","Error","error","catch","e","toString","setAccountToUnlock","index","parseInt","addAccounts","n","from","to","i","address","_addressFromIndex","push","getFirstPage","_getPage","getNextPage","getPreviousPage","increment","balance","toChecksumAddress","getAccounts","slice","removeAccount","map","a","toLowerCase","includes","filter","signAndSendTransaction","fromAddress","transaction","provider","unlockResult","isNil","getSequenceOverride","sequence","getTransactionCount","setSequence","setFrom","signedTxRaw","signTransaction","result","sendTransaction","signMessage","withAccount","data","signPersonalMessage","message","signTypedData","typedData","exportAccount","forgetDevice","_normalize","buf","bufferToHex","dkey","derive","publicToAddress","_pathFromAddress","checksummedAddress"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/keyrings/trezor/index.js"],"sourcesContent":["import _ from 'lodash';\nimport Trezor from \"../../services/Trezor\";\nconst { EventEmitter } = require('events')\nconst ethUtil = require('ethereumjs-util')\nconst HDKey = require('hdkey')\nconst TrezorConnect = require('trezor-connect').default\nconst hdPathString = `m/44'/60'/0'/0`\nconst keyringType = 'Trezor Hardware'\nconst pathBase = 'm'\nconst MAX_INDEX = 1000\nconst DELAY_BETWEEN_POPUPS = 1000\nconst TREZOR_CONNECT_MANIFEST = {\n    email: 'support@dnerochain.org',\n    appUrl: 'https://wallet.dnerochain.org',\n    keepSession: true\n};\n\nclass TrezorKeyring extends EventEmitter {\n    constructor (opts = {}) {\n        super()\n        this.type = keyringType\n        this.accounts = []\n        this.hdk = new HDKey()\n        this.page = 0\n        this.perPage = 5\n        this.unlockedAccount = 0\n        this.paths = {}\n        this.deserialize(opts)\n        TrezorConnect.manifest(TREZOR_CONNECT_MANIFEST)\n    }\n\n    serialize () {\n        return Promise.resolve({\n            hdPath: this.hdPath,\n            accounts: this.accounts,\n            page: this.page,\n            paths: this.paths,\n            perPage: this.perPage,\n            unlockedAccount: this.unlockedAccount,\n        })\n    }\n\n    deserialize (opts = {}) {\n        this.hdPath = opts.hdPath || hdPathString\n        this.accounts = opts.accounts || []\n        this.page = opts.page || 0\n        this.perPage = opts.perPage || 5\n        return Promise.resolve()\n    }\n\n    isUnlocked () {\n        return !!(this.hdk && this.hdk.publicKey)\n    }\n\n    unlock () {\n        if (this.isUnlocked()) return Promise.resolve('already unlocked')\n        return new Promise((resolve, reject) => {\n            TrezorConnect.getPublicKey({\n                path: this.hdPath,\n                coin: 'ETH',\n            }).then(response => {\n                if (response.success) {\n                    this.hdk.publicKey = new Buffer(response.payload.publicKey, 'hex')\n                    this.hdk.chainCode = new Buffer(response.payload.chainCode, 'hex')\n                    resolve('just unlocked')\n                } else {\n                    reject(new Error(response.payload && response.payload.error || 'Unknown error'))\n                }\n            }).catch(e => {\n                reject(new Error(e && e.toString() || 'Unknown error'))\n            })\n        })\n    }\n\n    setAccountToUnlock (index) {\n        this.unlockedAccount = parseInt(index, 10)\n    }\n\n    addAccounts (n = 1) {\n        return new Promise((resolve, reject) => {\n            this.unlock()\n                .then(_ => {\n                    const from = this.unlockedAccount\n                    const to = from + n\n                    this.accounts = []\n\n                    for (let i = from; i < to; i++) {\n                        const address = this._addressFromIndex(pathBase, i)\n                        this.accounts.push(address)\n                        this.page = 0\n                    }\n                    resolve(this.accounts)\n                })\n                .catch(e => {\n                    reject(e)\n                })\n        })\n    }\n\n    getFirstPage () {\n        this.page = 0\n        return this._getPage(1)\n    }\n\n    getNextPage () {\n        return this._getPage(1)\n    }\n\n    getPreviousPage () {\n        return this._getPage(-1)\n    }\n\n    _getPage (increment) {\n        this.page += increment\n\n        if (this.page <= 0) { this.page = 1 }\n\n        return new Promise((resolve, reject) => {\n            this.unlock()\n                .then(_ => {\n\n                    const from = (this.page - 1) * this.perPage\n                    const to = from + this.perPage\n\n                    const accounts = []\n\n                    for (let i = from; i < to; i++) {\n                        const address = this._addressFromIndex(pathBase, i)\n                        accounts.push({\n                            address: address,\n                            balance: null,\n                            index: i,\n                        })\n                        this.paths[ethUtil.toChecksumAddress(address)] = i\n\n                    }\n                    resolve(accounts)\n                })\n                .catch(e => {\n                    reject(e)\n                })\n        })\n    }\n\n    getAccounts () {\n        return Promise.resolve(this.accounts.slice())\n    }\n\n    removeAccount (address) {\n        if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {\n            throw new Error(`Address ${address} not found in this keyring`)\n        }\n        this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase())\n    }\n\n    async signAndSendTransaction (fromAddress, transaction, provider) {\n        const unlockResult = await this.unlock();\n\n        if(_.isNil(transaction.getSequenceOverride())){\n            let sequence = await provider.getTransactionCount(fromAddress);\n            sequence = sequence + 1;\n            transaction.setSequence(sequence);\n        }\n        transaction.setFrom(ethUtil.toChecksumAddress(fromAddress));\n        const signedTxRaw = await Trezor.signTransaction(transaction);\n        const result = provider.sendTransaction(signedTxRaw);\n\n        return Promise.resolve(result);\n    }\n\n    signMessage (withAccount, data) {\n        return Promise.reject(new Error('Not supported on this device'))\n    }\n\n    // For personal_sign, we need to prefix the message:\n    signPersonalMessage (withAccount, message) {\n        return Promise.reject(new Error('Not supported on this device'))\n    }\n\n    signTypedData (withAccount, typedData) {\n        // Waiting on trezor to enable this\n        return Promise.reject(new Error('Not supported on this device'))\n    }\n\n    exportAccount (address) {\n        return Promise.reject(new Error('Not supported on this device'))\n    }\n\n    forgetDevice () {\n        this.accounts = []\n        this.hdk = new HDKey()\n        this.page = 0\n        this.unlockedAccount = 0\n        this.paths = {}\n    }\n\n    /* PRIVATE METHODS */\n\n    _normalize (buf) {\n        return ethUtil.bufferToHex(buf).toString()\n    }\n\n    _addressFromIndex (pathBase, i) {\n        const dkey = this.hdk.derive(`${pathBase}/${i}`)\n        const address = ethUtil\n            .publicToAddress(dkey.publicKey, true)\n            .toString('hex');\n        return ethUtil.toChecksumAddress(address).toLowerCase()\n    }\n\n    _pathFromAddress (address) {\n        const checksummedAddress = ethUtil.toChecksumAddress(address)\n        let index = this.paths[checksummedAddress]\n        if (typeof index === 'undefined') {\n            for (let i = 0; i < MAX_INDEX; i++) {\n                if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n                    index = i\n                    break\n                }\n            }\n        }\n\n        if (typeof index === 'undefined') {\n            throw new Error('Unknown address')\n        }\n        return `${this.hdPath}/${index}`\n    }\n}\n\nTrezorKeyring.type = keyringType;\n\nexport default TrezorKeyring;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}